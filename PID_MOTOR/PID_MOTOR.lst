CCS PCD C Compiler, Version 5.015, 5967               17-¾.Â.-17 23:05

               Filename:   C:\Users\Teng_is_happy\Documents\Embeded Project\PID_MOTOR\PID_MOTOR.lst

               ROM used:   4848 bytes (14%)
                           Largest free fragment is 25868
               RAM used:   252 (3%) at main() level
                           298 (4%) worst case
               Stack size: 128

*
0C00:  GOTO    1E02
*
0C28:  GOTO    F28
*
0C30:  GOTO    E94
*
0C38:  GOTO    F6C
*
0C74:  GOTO    EE0
*
0C90:  GOTO    1A9A
0C94:  GOTO    1BF2
0C98:  GOTO    F04
*
0CB8:  GOTO    FB2
0CBC:  GOTO    1006
.................... #import(file="CONTROL_PID.o") 
.................... /* 
.................... *************************** C SOURCE FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONTROL_PID.C 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #define CONTROL_PID_C_SRC 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             MODULES USED                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #include "CONTROL_PID.h" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONTROL_PID.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  CONTROL_PID_INCLUDED 
.................... #define  CONTROL_PID_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... //#include <stdlib.h>  // depend on application requirements. 
.................... //#include "cdat68k.h"  // define data types 
.................... #include "CONFIG_PIC24.H" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONFIG_PIC24.H 
.................... version   :  
.................... date      : 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  CONFIG_PIC24_INCLUDED 
.................... #define  CONFIG_PIC24_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include <24FJ48GA002.H> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
*
0DFC:  CLR     32
0DFE:  MOV     #E08,W3
0E00:  ADD     W3,W0,W0
0E02:  TBLRDL.B[W0],W0L
0E04:  CLR.B   1
0E06:  RETURN  
0E08:  DATA    0A,63,00
0E0A:  DATA    75,72,00
0E0C:  DATA    72,65,00
0E0E:  DATA    6E,74,00
0E10:  DATA    5F,70,00
0E12:  DATA    6F,73,00
0E14:  DATA    58,20,00
0E16:  DATA    3D,20,00
0E18:  DATA    25,64,00
0E1A:  DATA    00,00,00
*
105A:  MOV     W5,[W15++]
105C:  MOV     #C,W5
105E:  REPEAT  #3
1060:  MOV     [W5++],[W15++]
1062:  MOV     W0,W4
1064:  MOV     W1,W5
1066:  MOV     W2,W6
1068:  MOV     W3,W7
106A:  CLR     W0
106C:  CLR     W1
106E:  CLR     W2
1070:  CLR     W3
1072:  BCLR    W8.0
1074:  BTSS    W7.F
1076:  BRA     1082
1078:  BSET    W8.0
107A:  NEG     W4,W4
107C:  COM     W5,W5
107E:  COM     W6,W6
1080:  COM     W7,W7
1082:  IOR      W4,  W5,W9
1084:  BRA     NZ,108A
1086:  IOR      W6,  W7,W9
1088:  BRA     Z,10B4
108A:  MOV     #473,W9
108C:  BTSC    W3.4
108E:  BRA     10A6
1090:  BCLR.B  42.0
1092:  RLC     W4,W4
1094:  RLC     W5,W5
1096:  RLC     W6,W6
1098:  RLC     W7,W7
109A:  RLC     W0,W0
109C:  RLC     W1,W1
109E:  RLC     W2,W2
10A0:  RLC     W3,W3
10A2:  DEC     W9,W9
10A4:  BRA     NZ,108C
10A6:  SL      W9,#4,W9
10A8:  BCLR.B  42.0
10AA:  BCLR    W9.F
10AC:  BCLR    W3.4
10AE:  XOR     W9,W3,W3
10B0:  BTSC    W8.0
10B2:  BSET    W3.F
10B4:  MOV     #12,W5
10B6:  REPEAT  #3
10B8:  MOV     [--W15],[W5--]
10BA:  MOV     [--W15],W5
10BC:  RETURN  
10BE:  MOV     W8,[W15++]
10C0:  MOV     #12,W8
10C2:  REPEAT  #4
10C4:  MOV     [W8++],[W15++]
10C6:  CLR     W11
10C8:  MUL.UU  W12,#0,W12
10CA:  MOV     W3,W8
10CC:  MOV     W7,W9
10CE:  MOV     #7FF,W10
10D0:  BCLR.B  42.0
10D2:  BCLR.B  42.1
10D4:  ASR     W8,#4,W8
10D6:  AND     W10,W8,W8
10D8:  CP0     W8
10DA:  BRA     Z,11BE
10DC:  BCLR.B  42.0
10DE:  BCLR.B  42.1
10E0:  ASR     W9,#4,W9
10E2:  AND     W10,W9,W9
10E4:  CP0     W9
10E6:  BRA     Z,11BE
10E8:  ADD     W9,W8,W8
10EA:  BTSC    W9.B
10EC:  BRA     10F6
10EE:  SUB     #3FF,W8
10F0:  BRA     Z,11BE
10F2:  BRA     NC,11BE
10F4:  BRA     10FC
10F6:  MOV     #401,W10
10F8:  ADD.B   W10L,W5L,W5L
10FA:  BRA     C,11BE
10FC:  XOR     W3,W7,W13
10FE:  BCLR.B  42.0
1100:  BCLR.B  42.1
1102:  AND     #F,W3
1104:  BSET    W3.4
1106:  AND     #F,W7
1108:  BSET    W7.4
110A:  MOV     W8,[W15++]
110C:  MUL.UU  W4,W1,W8
110E:  MUL.UU  W5,W0,W10
1110:  ADD     W8,W10,W10
1112:  ADDC    W9,W11,W11
1114:  ADDC    #0,W12
1116:  MUL.UU  W4,W2,W8
1118:  ADD     W8,W11,W11
111A:  ADDC    W9,W12,W12
111C:  MUL.UU  W5,W1,W8
111E:  CLR     W10
1120:  ADD     W8,W11,W11
1122:  ADDC    W9,W12,W12
1124:  ADDC    #0,W10
1126:  MUL.UU  W6,W0,W8
1128:  ADD     W8,W11,W11
112A:  ADDC    W9,W12,W12
112C:  ADDC    #0,W10
112E:  CLR     W11
1130:  MUL.UU  W4,W3,W8
1132:  ADD     W8,W12,W12
1134:  ADDC    W9,W10,W10
1136:  ADDC    #0,W11
1138:  MUL.UU  W5,W2,W8
113A:  ADD     W8,W12,W12
113C:  ADDC    W9,W10,W10
113E:  ADDC    #0,W11
1140:  MUL.UU  W6,W1,W8
1142:  ADD     W8,W12,W12
1144:  ADDC    W9,W10,W10
1146:  ADDC    #0,W11
1148:  MUL.UU  W7,W0,W8
114A:  ADD     W8,W12,W12
114C:  ADDC    W9,W10,W10
114E:  ADDC    #0,W11
1150:  MOV     W12,W0
1152:  CLR     W12
1154:  MUL.UU  W5,W3,W8
1156:  ADD     W8,W10,W10
1158:  ADDC    W9,W11,W11
115A:  ADDC    #0,W12
115C:  MUL.UU  W6,W2,W8
115E:  ADD     W8,W10,W10
1160:  ADDC    W9,W11,W11
1162:  ADDC    #0,W12
1164:  MUL.UU  W6,W3,W8
1166:  ADD     W8,W11,W11
1168:  ADDC    W9,W12,W12
116A:  MUL.UU  W7,W1,W8
116C:  ADD     W8,W10,W10
116E:  ADDC    W9,W11,W11
1170:  ADDC    #0,W12
1172:  MUL.UU  W7,W2,W8
1174:  ADD     W8,W11,W11
1176:  ADDC    W9,W12,W12
1178:  MUL.UU  W7,W3,W8
117A:  ADD     W8,W12,W12
117C:  MOV     W10,W1
117E:  MOV     W11,W2
1180:  MOV     W12,W3
1182:  MOV     #5,W4
1184:  BCLR.B  42.0
1186:  RRC     W3,W3
1188:  RRC     W2,W2
118A:  RRC     W1,W1
118C:  RRC     W0,W0
118E:  DEC     W4,W4
1190:  BRA     NZ,1184
1192:  MOV     [--W15],W8
1194:  INC     W8,W8
1196:  IOR      W0,  W1,W6
1198:  BRA     Z,119C
119A:  BRA     11A0
119C:  IOR      W2,  W3,W6
119E:  BRA     Z,11B0
11A0:  BTSC    W3.4
11A2:  BRA     11B0
11A4:  BCLR.B  42.0
11A6:  RLC     W0,W0
11A8:  RLC     W1,W1
11AA:  RLC     W2,W2
11AC:  RLC     W3,W3
11AE:  DEC     W8,W8
11B0:  SL      W8,#4,W8
11B2:  BCLR    W3.F
11B4:  BTSC    W13.F
11B6:  BSET    W3.F
11B8:  BCLR    W3.4
11BA:  XOR     W8,W3,W3
11BC:  BRA     11C4
11BE:  MUL.UU  W0,#0,W0
11C0:  MUL.UU  W0,#0,W2
11C2:  BRA     11C4
11C4:  MOV     #1A,W8
11C6:  REPEAT  #4
11C8:  MOV     [--W15],[W8--]
11CA:  MOV     [--W15],W8
11CC:  RETURN  
11CE:  MOV     W8,[W15++]
11D0:  MOV     #12,W8
11D2:  REPEAT  #4
11D4:  MOV     [W8++],[W15++]
11D6:  XOR     W3,W7,W13
11D8:  MOV     W3,W8
11DA:  MOV     W7,W9
11DC:  MOV     #7FF,W10
11DE:  BCLR.B  42.0
11E0:  BCLR.B  42.1
11E2:  ASR     W8,#4,W8
11E4:  AND     W10,W8,W8
11E6:  CP0     W8
11E8:  BRA     Z,12C2
11EA:  BCLR.B  42.0
11EC:  BCLR.B  42.1
11EE:  ASR     W9,#4,W9
11F0:  AND     W10,W9,W9
11F2:  CP0     W9
11F4:  BRA     Z,12C2
11F6:  CLR     W10
11F8:  SUB     W8,W9,W12
11FA:  BRA     NC,1202
11FC:  ADD     #3FF,W12
11FE:  BRA     C,12C2
1200:  BRA     120A
1202:  MOV     #401,W11
1204:  SUB     W12,W11,W12
1206:  BRA     NC,12C2
1208:  BRA     Z,12C2
120A:  CLR     W8
120C:  CLR     W9
120E:  CLR     W10
1210:  CLR     W11
1212:  AND     #1F,W3
1214:  BSET    W3.4
1216:  AND     #1F,W7
1218:  BSET    W7.4
121A:  MOV     W12,[W15++]
121C:  MOV     #36,W12
121E:  SUB     W0,W4,W0
1220:  SUBB    W1,W5,W1
1222:  SUBB    W2,W6,W2
1224:  SUBB    W3,W7,W3
1226:  BRA     N,122C
1228:  BRA     C,1236
122A:  BRA     NZ,1238
122C:  ADD     W0,W4,W0
122E:  ADDC    W1,W5,W1
1230:  ADDC    W2,W6,W2
1232:  ADDC    W3,W7,W3
1234:  BRA     1238
1236:  BSET    W8.0
1238:  DEC     W12,W12
123A:  BRA     Z,1252
123C:  BCLR.B  42.0
123E:  RLC     W0,W0
1240:  RLC     W1,W1
1242:  RLC     W2,W2
1244:  RLC     W3,W3
1246:  BCLR.B  42.0
1248:  RLC     W8,W8
124A:  RLC     W9,W9
124C:  RLC     W10,W10
124E:  RLC     W11,W11
1250:  BRA     121E
1252:  MOV     [--W15],W12
1254:  BTSC    W11.5
1256:  BRA     125A
1258:  BRA     1266
125A:  BCLR.B  42.0
125C:  RRC     W11,W11
125E:  RRC     W10,W10
1260:  RRC     W9,W9
1262:  RRC     W8,W8
1264:  BRA     126C
1266:  DEC     W12,W12
1268:  BCLR.B  42.0
126A:  BRA     Z,12C2
126C:  BTSC.B  42.0
126E:  BRA     1282
1270:  RLC     W0,W0
1272:  RLC     W1,W1
1274:  RLC     W2,W2
1276:  RLC     W3,W3
1278:  SUB     W0,W4,W4
127A:  SUBB    W1,W5,W5
127C:  SUBB    W2,W6,W6
127E:  SUBB    W3,W7,W7
1280:  BRA     NC,12AC
1282:  INC     W8,W8
1284:  BRA     NZ,12AC
1286:  INC     W9,W9
1288:  BRA     NZ,12AC
128A:  INC     W10,W10
128C:  BRA     NZ,12AC
128E:  INC     W11,W11
1290:  BRA     NZ,12AC
1292:  INC     W12,W12
1294:  BRA     Z,12C2
1296:  BRA     12AC
1298:  DEC     W12,W12
129A:  BRA     Z,12C2
129C:  BTSC    W11.4
129E:  BRA     12AC
12A0:  BCLR.B  42.0
12A2:  RLC     W8,W8
12A4:  RLC     W9,W9
12A6:  RLC     W10,W10
12A8:  RLC     W11,W11
12AA:  BRA     129C
12AC:  SL      W12,#4,W12
12AE:  BCLR.B  42.0
12B0:  BCLR    W12.F
12B2:  BTSC    W13.F
12B4:  BSET    W12.F
12B6:  BCLR    W11.4
12B8:  XOR     W12,W11,W3
12BA:  MOV     W10,W2
12BC:  MOV     W9,W1
12BE:  MOV     W8,W0
12C0:  BRA     12CC
12C2:  MOV     #0,W0
12C4:  MOV     #0,W1
12C6:  MOV     #0,W2
12C8:  MOV     #0,W3
12CA:  BRA     12CC
12CC:  MOV     #1A,W8
12CE:  REPEAT  #4
12D0:  MOV     [--W15],[W8--]
12D2:  MOV     [--W15],W8
12D4:  RETURN  
12D6:  MOV     W5,[W15++]
12D8:  MOV     W6,[W15++]
12DA:  MOV     W3,W4
12DC:  MOV     W3,W6
12DE:  BCLR.B  42.0
12E0:  ASR     W4,#4,W4
12E2:  MOV     #7FF,W5
12E4:  AND     W5,W4,W4
12E6:  BRA     NZ,12EE
12E8:  MUL.UU  W0,#0,W0
12EA:  CLR     W2
12EC:  BRA     1314
12EE:  SUB     #380,W4
12F0:  AND     #F,W3
12F2:  MOV     #3,W7
12F4:  BCLR.B  42.0
12F6:  RLC     W0,W0
12F8:  RLC     W1,W1
12FA:  RLC     W2,W2
12FC:  RLC     W3,W3
12FE:  DEC     W7,W7
1300:  BRA     NZ,12F4
1302:  MOV     W1,W0
1304:  MOV     W2,W1
1306:  BCLR    W3.7
1308:  SWAP    W4
130A:  BCLR.B  42.0
130C:  RRC     W4,W4
130E:  BTSC    W6.F
1310:  BSET    W4.F
1312:  XOR     W4,W3,W2
1314:  MOV     [--W15],W6
1316:  MOV     [--W15],W5
1318:  RETURN  
131A:  MOV     W5,[W15++]
131C:  MOV     #C,W5
131E:  REPEAT  #4
1320:  MOV     [W5++],[W15++]
1322:  MOV     W0,W4
1324:  MOV     W1,W5
1326:  MOV     W3,W7
1328:  MOV     W2,W6
132A:  BCLR.B  42.0
132C:  BCLR.B  42.1
132E:  RLC     W1,W1
1330:  SWAP    W1
1332:  AND     #FF,W1
1334:  CP0     W1
1336:  BRA     Z,13CE
1338:  BCLR.B  42.0
133A:  BCLR.B  42.1
133C:  RLC     W3,W3
133E:  SWAP    W3
1340:  AND     #FF,W3
1342:  CP0     W3
1344:  BRA     Z,13CE
1346:  ZE      W0,W0
1348:  ADD.B   W3L,W1L,W0L
134A:  BRA     C,1354
134C:  SUB     #7F,W0
134E:  BRA     Z,13CE
1350:  BRA     NC,13CE
1352:  BRA     1358
1354:  ADD.B   #81,W0L
1356:  BRA     C,13CE
1358:  XOR     W5,W7,W10
135A:  BCLR.B  42.0
135C:  BCLR.B  42.1
135E:  AND     #FF,W5
1360:  BSET    W5.7
1362:  BCLR.B  42.0
1364:  AND     #FF,W7
1366:  BSET    W7.7
1368:  MUL.UU  W4,W6,W2
136A:  MUL.UU  W5,W6,W8
136C:  ADDC    W8,W3,W3
136E:  MOV     W9,W1
1370:  BTSC.B  42.0
1372:  INC     W1,W1
1374:  BCLR.B  42.0
1376:  MUL.UU  W7,W4,W8
1378:  ADDC    W8,W3,W3
137A:  ADDC    W9,W1,W1
137C:  MUL.UU  W5,W7,W8
137E:  ADDC    W8,W1,W1
1380:  INC     W0,W0
1382:  CP0     W1
1384:  BTSC.B  42.1
1386:  BRA     138A
1388:  BRA     1390
138A:  CP0     W3
138C:  BTSC.B  42.1
138E:  BRA     139A
1390:  BTSC    W1.F
1392:  BRA     139A
1394:  RLC     W3,W3
1396:  RLC     W1,W1
1398:  DEC     W0,W0
139A:  MOV     W1,W2
139C:  BCLR.B  42.0
139E:  BTSS    W3.7
13A0:  BRA     13B4
13A2:  MOV     #FF00,W7
13A4:  AND     W3,W7,W3
13A6:  ADD     #100,W3
13A8:  ADDC    W2,#0,W2
13AA:  CP0     W2
13AC:  BRA     NZ,13B4
13AE:  CP0     W3
13B0:  BRA     NZ,13B4
13B2:  INC     W0,W0
13B4:  SWAP    W0
13B6:  BCLR.B  42.0
13B8:  BCLR.B  42.1
13BA:  RRC     W0,W1
13BC:  BTSC    W10.F
13BE:  BSET    W1.F
13C0:  BCLR    W2.F
13C2:  SWAP    W2
13C4:  XOR.B   W2L,W1L,W1L
13C6:  SWAP    W3
13C8:  MOV.B   W3L,W2L
13CA:  MOV     W2,W0
13CC:  BRA     13D4
13CE:  MOV     #0,W0
13D0:  MOV     #0,W1
13D2:  BRA     13D4
13D4:  MOV     #14,W5
13D6:  REPEAT  #4
13D8:  MOV     [--W15],[W5--]
13DA:  MOV     [--W15],W5
13DC:  RETURN  
13DE:  MOV     W5,[W15++]
13E0:  MOV     #C,W5
13E2:  REPEAT  #4
13E4:  MOV     [W5++],[W15++]
13E6:  CLR     W9
13E8:  XOR     W1,W3,W9
13EA:  MOV     W1,W6
13EC:  MOV     W0,W5
13EE:  MOV     W3,W8
13F0:  MOV     W2,W7
13F2:  RLC     W1,W1
13F4:  SWAP    W1
13F6:  ZE      W1,W1
13F8:  CP0     W1
13FA:  BRA     Z,1498
13FC:  RLC     W3,W3
13FE:  SWAP    W3
1400:  ZE      W3,W3
1402:  CP0     W3
1404:  BRA     Z,1498
1406:  CLR     W0
1408:  SUB.B   W1L,W3L,W0L
140A:  BRA     NC,1412
140C:  ADD.B   #7F,W0L
140E:  BRA     C,1498
1410:  BRA     1418
1412:  SUB.B   #81,W0L
1414:  BRA     NC,1498
1416:  BRA     Z,1498
1418:  MOV     W5,W1
141A:  MOV     W6,W2
141C:  BSET    W2.7
141E:  AND     #FF,W2
1420:  AND     #FF,W8
1422:  BSET    W8.7
1424:  MOV     #19,W10
1426:  CLR     W3
1428:  CLR     W4
142A:  SUB     W1,W7,W1
142C:  SUBB    W2,W8,W2
142E:  BRA     N,1434
1430:  BRA     C,143A
1432:  BRA     NZ,143C
1434:  ADD     W1,W7,W1
1436:  ADDC    W2,W8,W2
1438:  BRA     143C
143A:  BSET    W4.0
143C:  DEC     W10,W10
143E:  BRA     Z,144E
1440:  BCLR.B  42.0
1442:  RLC     W1,W1
1444:  RLC     W2,W2
1446:  BCLR.B  42.0
1448:  RLC     W4,W4
144A:  RLC     W3,W3
144C:  BRA     142A
144E:  CLR     W10
1450:  BTSC    W3.8
1452:  BRA     1456
1454:  BRA     1462
1456:  BCLR.B  42.0
1458:  RRC     W3,W3
145A:  BCLR    W3.7
145C:  RRC     W4,W4
145E:  RLC     W10,W10
1460:  BRA     1466
1462:  DEC     W0,W0
1464:  BRA     Z,1498
1466:  BTSC    W10.F
1468:  BRA     NC,1474
146A:  RLC     W1,W1
146C:  RLC     W2,W2
146E:  SUB     W1,W7,W1
1470:  SUBB    W2,W8,W2
1472:  BRA     NC,1486
1474:  INC     W4,W4
1476:  BRA     NZ,1486
1478:  INC     W3,W3
147A:  BRA     NZ,1486
147C:  INC     W0,W0
147E:  BRA     Z,1498
1480:  BRA     1486
1482:  DEC     W0,W0
1484:  BRA     Z,1498
1486:  SWAP    W0
1488:  RRC     W0,W1
148A:  BSET    W1.F
148C:  BTSS    W9.F
148E:  BCLR    W1.F
1490:  BCLR    W3.7
1492:  XOR.B   W3L,W1L,W1L
1494:  MOV     W4,W0
1496:  BRA     149E
1498:  MOV     #0,W0
149A:  MOV     #0,W1
149C:  BRA     149E
149E:  MOV     #14,W5
14A0:  REPEAT  #4
14A2:  MOV     [--W15],[W5--]
14A4:  MOV     [--W15],W5
14A6:  RETURN  
14A8:  MOV     W0,W2
14AA:  MOV     W1,W3
14AC:  MOV.B   W1L,W0L
14AE:  SWAP    W0
14B0:  BSET    W0.F
14B2:  RLC     W1,W1
14B4:  SWAP    W1
14B6:  ZE      W1,W1
14B8:  MOV     #8E,W4
14BA:  SUB.B   W4L,W1L,W1L
14BC:  BRA     Z,14CA
14BE:  CP0     W0
14C0:  BRA     Z,14CA
14C2:  BCLR.B  42.0
14C4:  RRC     W0,W0
14C6:  DEC     W1,W1
14C8:  BRA     NZ,14BE
14CA:  BTSS    W3.F
14CC:  BRA     14D2
14CE:  NEG     W0,W0
14D0:  BRA     14D2
14D2:  RETURN  
14D4:  MOV     W5,[W15++]
14D6:  MOV     #C,W5
14D8:  REPEAT  #3
14DA:  MOV     [W5++],[W15++]
14DC:  BTSS    W0.F
14DE:  BRA     14F8
14E0:  NEG     W0,W0
14E2:  BSET    W4.8
14E4:  BTSS    W4.F
14E6:  BRA     14F8
14E8:  MOV     W0,[W15++]
14EA:  MOV     #2D,W0
14EC:  BTSC.B  223.1
14EE:  BRA     14EC
14F0:  MOV     W0,224
14F2:  MOV     [--W15],W0
14F4:  BCLR    W4.8
14F6:  DEC.B   0008
14F8:  CLR     W5
14FA:  MOV     W0,W7
14FC:  MOV     W4,W9
14FE:  BCLR    W4.F
1500:  CP0.B   W4L
1502:  BRA     NZ,1510
1504:  BTSC    W9.F
1506:  BRA     150C
1508:  MOV     #0,W5
150A:  BRA     152A
150C:  MOV     #0,W5
150E:  BRA     152A
1510:  SUB.B   W4L,#6,W5L
1512:  BRA     NC,1528
1514:  MOV     #30,W0
1516:  BTSS    W9.F
1518:  MOV     #20,W0
151A:  BTSC.B  223.1
151C:  BRA     151A
151E:  MOV     W0,224
1520:  DEC     W5,W5
1522:  BRA     NN,151A
1524:  MOV     #5,W5
1526:  BRA     152A
1528:  MOV     W4,W5
152A:  MOV     #6,W4
152C:  BTSC    W5.8
152E:  INC     W4,W4
1530:  BSET    W5.E
1532:  BTSC    W9.F
1534:  BSET    W5.F
1536:  MOV     #2710,W8
1538:  REPEAT  #11
153A:  DIV.U   W7,W8
153C:  CALL    1580
1540:  MOV     W1,W7
1542:  MOV     #3E8,W8
1544:  REPEAT  #11
1546:  DIV.U   W7,W8
1548:  CALL    1580
154C:  MOV     W1,W7
154E:  MOV     #64,W8
1550:  REPEAT  #11
1552:  DIV.U   W7,W8
1554:  CALL    1580
1558:  MOV     W1,W7
155A:  MOV     #A,W8
155C:  REPEAT  #11
155E:  DIV.U   W7,W8
1560:  CALL    1580
1564:  BTSS    W9.8
1566:  BRA     1572
1568:  MOV     #2D,W0
156A:  BTSC.B  223.1
156C:  BRA     156A
156E:  MOV     W0,224
1570:  BCLR    W9.8
1572:  MOV     #30,W0
1574:  ADD.B   W1L,W0L,W0L
1576:  MOV     W0,2A
1578:  BTSC.B  223.1
157A:  BRA     1578
157C:  MOV     W0,224
157E:  BRA     15C0
1580:  MOV     #30,W6
1582:  CP0     W0
1584:  BRA     NZ,15A2
1586:  BTSS    W5.E
1588:  BRA     15B6
158A:  DEC     W4,W4
158C:  CP.B    W4L,W5L
158E:  BRA     Z,1594
1590:  BTSC.B  42.0
1592:  RETURN  
1594:  CP0     W0
1596:  BRA     NZ,15A2
1598:  BTSS    W5.E
159A:  BRA     15B6
159C:  BTSS    W5.F
159E:  MOV     #20,W6
15A0:  BRA     15B6
15A2:  BCLR    W5.E
15A4:  BTSS    W9.8
15A6:  BRA     15B6
15A8:  MOV     W0,W10
15AA:  MOV     #2D,W0
15AC:  BTSC.B  223.1
15AE:  BRA     15AC
15B0:  MOV     W0,224
15B2:  BCLR    W9.8
15B4:  MOV     W10,W0
15B6:  ADD.B   W6L,W0L,W0L
15B8:  BTSC.B  223.1
15BA:  BRA     15B8
15BC:  MOV     W0,224
15BE:  RETURN  
15C0:  MOV     #12,W5
15C2:  REPEAT  #3
15C4:  MOV     [--W15],[W5--]
15C6:  MOV     [--W15],W5
15C8:  RETURN  
15CA:  MOV     W5,[W15++]
15CC:  MOV     #C,W5
15CE:  REPEAT  #3
15D0:  MOV     [W5++],[W15++]
15D2:  CLR     W9
15D4:  MOV     #8000,W8
15D6:  BTSC.B  43.0
15D8:  XOR     W8,W3,W3
15DA:  CP0     W0
15DC:  BRA     NZ,15E4
15DE:  MOV     #7FFF,W10
15E0:  AND     W1,W10,W10
15E2:  BTSS.B  42.1
15E4:  MOV     W1,W10
15E6:  XOR     W3,W10,W11
15E8:  MOV     W1,W6
15EA:  MOV     W3,W7
15EC:  MOV     W3,W12
15EE:  BCLR.B  42.1
15F0:  BCLR.B  42.0
15F2:  RLC     W6,W6
15F4:  SWAP    W6
15F6:  AND     #FF,W6
15F8:  CP0     W6
15FA:  BRA     Z,173E
15FC:  BCLR.B  42.1
15FE:  BCLR.B  42.0
1600:  RLC     W7,W7
1602:  SWAP    W7
1604:  AND     #FF,W7
1606:  CP0     W7
1608:  BRA     Z,1748
160A:  BCLR.B  42.1
160C:  BCLR.B  42.0
160E:  CP      W7,W6
1610:  BRA     Z,174A
1612:  BRA     N,175A
1614:  BCLR    W9.0
1616:  BSET    W9.1
1618:  SUB     W7,W6,W8
161A:  MOV     W7,W6
161C:  AND     #FF,W1
161E:  BSET    W1.7
1620:  AND     #FF,W3
1622:  BSET    W3.7
1624:  MOV     #28,W7
1626:  CP      W7,W8
1628:  BRA     N,164C
162A:  BCLR.B  42.1
162C:  BCLR.B  42.0
162E:  RRC     W1,W1
1630:  RRC     W0,W0
1632:  DEC     W8,W8
1634:  BRA     NZ,162A
1636:  BRA     1652
1638:  MOV     #28,W7
163A:  CP      W7,W8
163C:  BRA     N,1650
163E:  BCLR.B  42.1
1640:  BCLR.B  42.0
1642:  RRC     W3,W3
1644:  RRC     W2,W2
1646:  DEC     W8,W8
1648:  BRA     NZ,163E
164A:  BRA     166A
164C:  MOV     W2,W0
164E:  MOV     W3,W1
1650:  BRA     16D8
1652:  BTSS    W11.F
1654:  BRA     1678
1656:  BTSC    W9.4
1658:  MOV     W12,W11
165A:  NEG     W0,W0
165C:  BRA     Z,1662
165E:  COM.B   W1L,W1L
1660:  BRA     1664
1662:  NEG     W1,W1
1664:  BTSC    W9.4
1666:  BRA     16BE
1668:  BRA     1678
166A:  BTSS    W11.F
166C:  BRA     1678
166E:  NEG     W2,W2
1670:  BRA     Z,1676
1672:  COM.B   W3L,W3L
1674:  BRA     1678
1676:  NEG     W3,W3
1678:  AND     #FF,W5
167A:  BCLR.B  42.1
167C:  BCLR.B  42.0
167E:  ADD     W0,W2,W0
1680:  ADDC.B  W1L,W3L,W1L
1682:  BTSC.B  42.0
1684:  BSET    W9.3
1686:  BTSC    W9.0
1688:  BRA     169C
168A:  BTSC    W9.1
168C:  BRA     1690
168E:  BRA     16A6
1690:  BTSC    W11.F
1692:  BRA     16BE
1694:  BTSC    W9.3
1696:  BRA     16EA
1698:  BSET    W9.6
169A:  BRA     16D8
169C:  BTSC    W11.F
169E:  BRA     16BE
16A0:  BTSC    W9.3
16A2:  BRA     16EA
16A4:  BRA     16D8
16A6:  BCLR    W9.2
16A8:  BTSC    W11.F
16AA:  BRA     16B4
16AC:  MOV     W10,W11
16AE:  BTSC    W9.3
16B0:  BRA     16EA
16B2:  BRA     1720
16B4:  BSET    W9.4
16B6:  XOR.B   #80,W1L
16B8:  BTSC    W1.7
16BA:  BRA     1656
16BC:  MOV     W10,W11
16BE:  AND     #FF,W1
16C0:  IOR      W0,  W1,W7
16C2:  BRA     Z,16D8
16C4:  BTSC    W1.7
16C6:  BRA     16D8
16C8:  BCLR.B  42.1
16CA:  BCLR.B  42.0
16CC:  RLC     W0,W0
16CE:  RLC     W1,W1
16D0:  DEC     W6,W6
16D2:  BTSC.B  42.1
16D4:  BRA     1738
16D6:  BRA     16C4
16D8:  BTSC    W9.0
16DA:  MOV     W10,W11
16DC:  BTSC    W9.1
16DE:  MOV     W12,W11
16E0:  BTSS    W9.5
16E2:  BRA     1718
16E4:  BTSC    W10.F
16E6:  BSET    W0.8
16E8:  BRA     1720
16EA:  BSET.B  42.0
16EC:  RRC.B   W1L,W1L
16EE:  RRC     W0,W0
16F0:  BTSC.B  42.0
16F2:  BSET    W9.5
16F4:  INC     W6,W6
16F6:  BRA     Z,1738
16F8:  BTSS    W9.5
16FA:  BRA     170C
16FC:  INC     W0,W0
16FE:  BRA     NZ,170C
1700:  INC.B   W1L,W1L
1702:  BRA     NZ,170C
1704:  RRC.B   W1L,W1L
1706:  RRC     W0,W0
1708:  INC     W6,W6
170A:  BRA     Z,1738
170C:  BTSC    W9.0
170E:  MOV     W10,W11
1710:  BTSC    W9.1
1712:  MOV     W12,W11
1714:  BTSC.B  42.1
1716:  BRA     1738
1718:  BTSC    W9.6
171A:  MOV     W10,W11
171C:  BTSC    W9.7
171E:  MOV     W12,W11
1720:  IOR      W0,  W1,W2
1722:  BRA     Z,176A
1724:  BCLR    W1.7
1726:  SWAP    W6
1728:  BCLR.B  42.1
172A:  BCLR.B  42.0
172C:  RRC     W6,W6
172E:  XOR     W6,W1,W1
1730:  BSET    W1.F
1732:  BTSS    W11.F
1734:  BCLR    W1.F
1736:  BRA     176A
1738:  MOV     #0,W0
173A:  MOV     #0,W1
173C:  BRA     176A
173E:  BTSC    W10.F
1740:  XOR     W8,W3,W3
1742:  MOV     W2,W0
1744:  MOV     W3,W1
1746:  BRA     176A
1748:  BRA     176A
174A:  AND     #FF,W3
174C:  BSET    W3.7
174E:  AND     #FF,W1
1750:  BSET    W1.7
1752:  BTSC    W11.F
1754:  BCLR    W3.7
1756:  BSET    W9.2
1758:  BRA     166A
175A:  SUB     W6,W7,W8
175C:  AND     #FF,W1
175E:  BSET    W1.7
1760:  AND     #FF,W3
1762:  BSET    W3.7
1764:  BCLR    W9.1
1766:  BSET    W9.0
1768:  BRA     1638
176A:  MOV     #12,W5
176C:  REPEAT  #3
176E:  MOV     [--W15],[W5--]
1770:  MOV     [--W15],W5
1772:  RETURN  
1774:  MOV     W5,[W15++]
1776:  MOV     W6,[W15++]
1778:  MOV     #8E,W1
177A:  BCLR    W6.0
177C:  BTSS    W0.F
177E:  BRA     1786
1780:  BSET    W6.0
1782:  NEG     W0,W0
1784:  BRA     1786
1786:  CP0     W0
1788:  BRA     Z,17B2
178A:  BTSC    W0.F
178C:  BRA     1796
178E:  BCLR.B  42.0
1790:  RLC     W0,W0
1792:  DEC     W1,W1
1794:  BRA     178A
1796:  SWAP    W1
1798:  BCLR.B  42.0
179A:  RRC     W1,W1
179C:  BCLR    W0.F
179E:  SWAP    W0
17A0:  XOR.B   W0L,W1L,W1L
17A2:  AND.B   #0,W0L
17A4:  BTSC    W6.0
17A6:  BSET    W1.F
17A8:  BRA     17B8
17AA:  MOV.B   W1L,W0L
17AC:  BSET    W1.7
17AE:  AND.B   #0,W1L
17B0:  BRA     17B8
17B2:  CLR     W0
17B4:  CLR     W1
17B6:  BRA     17B8
17B8:  MOV     [--W15],W6
17BA:  MOV     [--W15],W5
17BC:  RETURN  
17BE:  MOV     W5,[W15++]
17C0:  MOV     W6,[W15++]
17C2:  MOV     W7,[W15++]
17C4:  XOR     W1,W3,W4
17C6:  BTSS    W4.F
17C8:  BRA     17D6
17CA:  BCLR.B  42.0
17CC:  BCLR.B  42.1
17CE:  BTSS    W1.F
17D0:  BRA     181E
17D2:  BSET.B  42.0
17D4:  BRA     181E
17D6:  MOV     W1,W4
17D8:  MOV     W0,W5
17DA:  MOV     W3,W6
17DC:  MOV     W2,W7
17DE:  RLC     W1,W1
17E0:  SWAP    W1
17E2:  RLC     W3,W3
17E4:  SWAP    W3
17E6:  SUB.B   W3L,W1L,W1L
17E8:  BRA     Z,17F4
17EA:  BTSS    W4.F
17EC:  BRA     181E
17EE:  MOV     #1,W0
17F0:  XOR.B   42
17F2:  BRA     181E
17F4:  MOV.B   W4L,W1L
17F6:  MOV.B   W6L,W3L
17F8:  BCLR    W1.7
17FA:  BCLR    W3.7
17FC:  SUB.B   W3L,W1L,W1L
17FE:  BRA     Z,180A
1800:  BTSS    W4.F
1802:  BRA     181E
1804:  MOV     #1,W0
1806:  XOR.B   42
1808:  BRA     181E
180A:  SUB     W7,W5,W1
180C:  BRA     Z,1818
180E:  BTSS    W4.F
1810:  BRA     181E
1812:  MOV     #1,W0
1814:  XOR.B   42
1816:  BRA     181E
1818:  BCLR.B  42.0
181A:  BRA     181E
181C:  BRA     181E
181E:  MOV     [--W15],W7
1820:  MOV     [--W15],W6
1822:  MOV     [--W15],W5
1824:  RETURN  
....................  
.................... #list 
....................  
.................... //#include <24FJ16GA002.H> 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #DEVICE ADC=10 
.................... #fuses NOIOL1WAY, NODEBUG, NOWRT, NOPROTECT, NOJTAG, NOWDT 
.................... #fuses OSCIO 
.................... #fuses FRC_PLL 
.................... #case 
.................... #type signed 
.................... #use delay(internal=8 MHz, clock = 32000000)  
.................... #use fast_io(ALL) 
.................... #pin_select U1TX = PIN_B13 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232 (UART1, BAUD = 115200, XMIT = PIN_B13, RCV = PIN_B12, STREAM = COM_A) 
.................... #BIT TX1IF = 0x0084.12  // Tx1 Interrupt flag  IFS0.12 
....................  
.................... ////////////////////////////////////////////////// 
.................... // EXT INT pins 
.................... #if 1 
.................... // INT0 is RB7 
.................... #pin_select INT1 = PIN_B5  //Limit Switch1 
.................... #pin_select INT2 = PIN_B4  //Limit Switch2 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... #if 0 
....................  
.................... #pin_select U2TX = PIN_B10 
.................... #pin_select U2RX = PIN_B11 
....................  
.................... //#use RS232 (UART2, BAUD = 9600, XMIT = PIN_B9, RCV = PIN_B8, STREAM = COM_B) 
.................... //#use RS232 (BAUD = 9600, XMIT = PIN_B10, RCV = PIN_B11, STREAM = COM_B) 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... // REMAP i/o pins 
.................... #if 1 
.................... #pin_select OC1 = PIN_B6   //ENA1 
.................... #pin_select OC2 = PIN_B7   //ENA2 
.................... #pin_select IC1 = PIN_B0   //Encoder1_A 
.................... #pin_select IC2 = PIN_B1   //Encoder1_B 
.................... #pin_select IC3 = PIN_B2   //Encoder2_A 
.................... #pin_select IC4 = PIN_B3   //B3 = Encoder2_B 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
....................  
.................... #include <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
*
1ECA:  CLR     800
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
*
1EC4:  CLR     800
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu\r\n", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include "BL_support.h" 
.................... /******************************************************************************/ 
.................... /* File:    BL_Support.h													  */ 
.................... /* Author:  Dr.Santi Nuratch												  */ 
.................... /*          Embedded Computing and Control Lab., INC-KMUTT 				      */ 
.................... /* Created on 22 September 2016, 13:14										  */ 
.................... /******************************************************************************/ 
....................  
.................... #ifndef BL_SUPPORT_H 
.................... #define	BL_SUPPORT_H 
....................  
.................... /******************************************************************************/ 
.................... /*                   BOOTLOADER SUPPORT CONFIGURATION                         */ 
.................... /*                          (DO NOT CHANGE)                                   */ 
.................... /******************************************************************************/ 
.................... /* Bootloader */ 
.................... #define LOADER_PAGES 	3  
.................... #define ERASE_SIZE 		2048    /* 2048 bytes, 24-bit (3 bytes) per instruction, but it uses 4 bytes aligned --> 4 bytes per word */ 
....................                                 /* each block has 512 instructions (1024 words), each instruction requires 4 bytes (2 words), so 512*4 = 2048 bytes */ 
.................... #define LOADER_SIZE 	((LOADER_PAGES * (ERASE_SIZE/2)) - 1)   /* 2 bytes per address, so divided by 2, 2048/2 = 1024 */  
.................... #define LOADER_END  	LOADER_SIZE                             /* End address      */ 
.................... #define LOADER_ADDR 	0xC00//(LOADER_END - LOADER_SIZE)       /* Start address    */ 
....................  
.................... #build (reset=LOADER_END+1, interrupt=LOADER_END+5) 
.................... #org 0, LOADER_END {}   /* 0x0000 - END */ 
....................  
.................... /******************************************************************************/ 
.................... /*                                  END                                       */ 
.................... /******************************************************************************/ 
....................  
.................... #endif	/* BL_SUPPORT_H */ 
....................  
....................  
.................... /****************************************************************************/ 
.................... // o/p pins  LED 
.................... #define  IN1  PIN_A0 
.................... #define  IN2  PIN_A1   
.................... #define  IN3  PIN_A2   
.................... #define  IN4  PIN_A4   
....................  
.................... // i/p pins  PBSW 
.................... #define  SW0  PIN_B1   //Encoder1B 
.................... #define  SW1  PIN_B3   //Encoder2B 
.................... #define  SW2  PIN_B6 
.................... #define  SW3  PIN_B7 
....................  
.................... // ADC  or  i/o pins if not use ADC 
.................... #define  AX0  PIN_A0 
.................... #define  AX1  PIN_A1 
.................... #define  AX2  PIN_B0  // RP0 remap pin 
.................... #define  AX3  PIN_B1  // RP1 remap pin 
....................  
.................... /****************************************************************************/ 
....................  
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... #include "CDATPIC24.H" 
.................... /* 
.................... ***************************   C DATA TYPE   ******************************* 
.................... **                                                                              
.................... **  project     : C Data Types Extension                                                 
.................... **  filename  : CDATPIC24.H                                                                 
.................... **                                                                                                                
.................... *************************************************************************** 
.................... */ 
....................  
.................... #ifndef   CDATPIC24_INCLUDED 
.................... #define   CDATPIC24_INCLUDED 
....................  
.................... /* 
.................... *************************************************************************** 
....................                             C  TYPEDEFS                                            
.................... *************************************************************************** 
.................... */ 
....................  
.................... /**** C type extensions ****/ 
.................... typedef unsigned char      int8u; 
.................... typedef signed   char      int8s; 
.................... typedef unsigned int       int16u; 
.................... typedef signed   int       int16s; 
.................... typedef unsigned long      int32u; 
.................... typedef signed   long      int32s; 
.................... typedef unsigned long long int64u; 
.................... typedef signed   long long int64s; 
....................  
....................  
.................... #endif 
.................... /* 
.................... ************************************************************************** 
....................                                EOF                                                    
.................... /************************************************************************* 
.................... */ 
....................  
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #ifndef CONTROL_PID_C_SRC 
....................  
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #include "BITWISE_LIB.h" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : BITWISE_LIB.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  BITWISE_LIB_INCLUDED 
.................... #define  BITWISE_LIB_INCLUDED 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include "CONFIG_PIC24.H"   
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONFIG_PIC24.H 
.................... version   :  
.................... date      : 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  CONFIG_PIC24_INCLUDED 
.................... #define  CONFIG_PIC24_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include <24FJ48GA002.H> 
.................... //#include <24FJ16GA002.H> 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #DEVICE ADC=10 
.................... #fuses NOIOL1WAY, NODEBUG, NOWRT, NOPROTECT, NOJTAG, NOWDT 
.................... #fuses OSCIO 
.................... #fuses FRC_PLL 
.................... #case 
.................... #type signed 
.................... #use delay(internal=8 MHz, clock = 32000000)  
.................... #use fast_io(ALL) 
.................... #pin_select U1TX = PIN_B13 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232 (UART1, BAUD = 115200, XMIT = PIN_B13, RCV = PIN_B12, STREAM = COM_A) 
.................... #BIT TX1IF = 0x0084.12  // Tx1 Interrupt flag  IFS0.12 
....................  
.................... ////////////////////////////////////////////////// 
.................... // EXT INT pins 
.................... #if 1 
.................... // INT0 is RB7 
.................... #pin_select INT1 = PIN_B5  //Limit Switch1 
.................... #pin_select INT2 = PIN_B4  //Limit Switch2 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... #if 0 
....................  
.................... #pin_select U2TX = PIN_B10 
.................... #pin_select U2RX = PIN_B11 
....................  
.................... //#use RS232 (UART2, BAUD = 9600, XMIT = PIN_B9, RCV = PIN_B8, STREAM = COM_B) 
.................... //#use RS232 (BAUD = 9600, XMIT = PIN_B10, RCV = PIN_B11, STREAM = COM_B) 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... // REMAP i/o pins 
.................... #if 1 
.................... #pin_select OC1 = PIN_B6   //ENA1 
.................... #pin_select OC2 = PIN_B7   //ENA2 
.................... #pin_select IC1 = PIN_B0   //Encoder1_A 
.................... #pin_select IC2 = PIN_B1   //Encoder1_B 
.................... #pin_select IC3 = PIN_B2   //Encoder2_A 
.................... #pin_select IC4 = PIN_B3   //B3 = Encoder2_B 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
....................  
.................... #include <stdlib.h>   
.................... #include <stdio.h> 
.................... #include <stdlibm.h> 
.................... #include <string.h> 
.................... #include <stdint.h> 
.................... #include "BL_support.h" 
.................... /****************************************************************************/ 
.................... // o/p pins  LED 
.................... #define  IN1  PIN_A0 
.................... #define  IN2  PIN_A1   
.................... #define  IN3  PIN_A2   
.................... #define  IN4  PIN_A4   
....................  
.................... // i/p pins  PBSW 
.................... #define  SW0  PIN_B1   //Encoder1B 
.................... #define  SW1  PIN_B3   //Encoder2B 
.................... #define  SW2  PIN_B6 
.................... #define  SW3  PIN_B7 
....................  
.................... // ADC  or  i/o pins if not use ADC 
.................... #define  AX0  PIN_A0 
.................... #define  AX1  PIN_A1 
.................... #define  AX2  PIN_B0  // RP0 remap pin 
.................... #define  AX3  PIN_B1  // RP1 remap pin 
....................  
.................... /****************************************************************************/ 
....................  
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... #include "CDATPIC24.H" 
.................... /* 
.................... ***************************   C DATA TYPE   ******************************* 
.................... **                                                                              
.................... **  project     : C Data Types Extension                                                 
.................... **  filename  : CDATPIC24.H                                                                 
.................... **                                                                                                                
.................... *************************************************************************** 
.................... */ 
....................  
.................... #ifndef   CDATPIC24_INCLUDED 
.................... #define   CDATPIC24_INCLUDED 
....................  
.................... /* 
.................... *************************************************************************** 
....................                             C  TYPEDEFS                                            
.................... *************************************************************************** 
.................... */ 
....................  
.................... /**** C type extensions ****/ 
.................... typedef unsigned char      int8u; 
.................... typedef signed   char      int8s; 
.................... typedef unsigned int       int16u; 
.................... typedef signed   int       int16s; 
.................... typedef unsigned long      int32u; 
.................... typedef signed   long      int32s; 
.................... typedef unsigned long long int64u; 
.................... typedef signed   long long int64s; 
....................  
....................  
.................... #endif 
.................... /* 
.................... ************************************************************************** 
....................                                EOF                                                    
.................... /************************************************************************* 
.................... */ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #ifndef BITWISE_LIB_C_SRC 
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                 Bitwise Library functions (Passed by value) 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                            FUNCTION : BitSet  
.................... // 
.................... // Description : Set a specified bit in 16-bit unsigned data to logic 1, other   
.................... //               bits are not changed 
.................... // Arguments   : "dat"     is the data whose a bit will be set 
.................... //               "bitPos"  is a specified bit position in "dat" which will be set,  
.................... //                            0 <= bitPos <= 15  (bit 0 is LSB, bit 15 is MSB)  
.................... // Returns     : value of "dat" with a bit at position "bitPos" was set to logic 1 
.................... /****************************************************************************/ 
....................  
.................... int16u BitSet (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitClear (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitInvt (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitTest (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
.................... /*****************************************************************************/ 
.................... //                 Bitwise Library functions (Passed by address) 
.................... /*****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                            FUNCTION : BitSetP  
.................... // 
.................... // Description : Set a specified bit in 16-bit unsigned variable to logic 1,    
.................... //               other bits are not changed 
.................... // Arguments   : "datPtr"  is the address of a variable whose a bit will be set 
.................... //               "bitPos"  is a specified bit position in the variable which   
.................... //                         will be set,   0 <= bitPos <= 15   
.................... //                         (bit 0 is LSB, bit 15 is MSB)  
.................... // Returns     : none 
.................... /****************************************************************************/ 
....................  
.................... void BitSetP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... void BitClearP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... void BitInvtP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitTestP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #define START_DUTY 0 
.................... #define Xaxis 0 
.................... #define Yaxis 1 
.................... #define Zaxis 2 
.................... #define STOP 0 
.................... #define PLUS 1 
.................... #define MINUS 2 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                      PROTOTYPES OF LOCAL FUNCTIONS                     **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... static void HardwareInit (void); 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED VARIABLES                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                            GLOBAL VARIABLES                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... float Kp = 0.0f,Kp_2 = 0.0f; 
.................... float Ki = 0.0f,Ki_2 = 0.0f; 
.................... float Kd = 0.0f,Kd_2 = 0.0f; 
.................... int16s e = 0,e_2 = 0; 
.................... float int_e = 0,int_e_2 = 0; 
.................... float u = 0,u_2 = 0; 
.................... float control = 0,control_2 = 0; 
.................... float p_e = 0,p_e_2 = 0; 
.................... float tor = 0.5; 
1EC6:  CLR     848
.................... static int16u duty1; 
.................... int32s count_pulseX = 0;  
.................... int32s count_pulseY = 0;  
.................... float thetaX = 0; 
.................... float thetaY = 0; 
.................... int target_posX = 180; 
.................... int target_posY = 0; 
.................... int h; 
.................... static float current_posX = 0; 
.................... static float current_posY = 0; 
.................... float current_pos_show = 0; 
.................... int16u ReadPortB,B0,B1,B2,B3; 
.................... float radius = 11.46; 
....................  
.................... int home_state = 1; 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED FUNCTIONS                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... void drive_motor(int axis,int direction,int speed){ 
.................... /*************************** 
.................... 	MotorLeft(CW) >> IN1  H 
.................... 				  >> IN2  L 
.................... 	MotorRight(CW) >> IN3  H 
.................... 	               >> IN4  L 
.................... 	Y_PLUS = Left(CW) + Right(CCW) 
.................... 	X_PLUS = Left(CW) + Right(CW) 
.................... ****************************/ 
.................... 	 
.................... 	if(speed == 0){ 
*
0E1C:  CP0     8A6
0E1E:  BRA     NZ,E2A
.................... 			output_high(IN1); 
0E20:  BSET.B  2C4.0
.................... 			output_high(IN2); 
0E22:  BSET.B  2C4.1
.................... 			output_high(IN3); 
0E24:  BSET.B  2C4.2
.................... 			output_high(IN4); 
0E26:  BSET.B  2C4.4
.................... 	} 
0E28:  BRA     E92
.................... 	else if(axis == Xaxis){ 
0E2A:  CP0     8A2
0E2C:  BRA     NZ,E5E
.................... 		if(direction == MINUS){ 
0E2E:  MOV     8A4,W4
0E30:  CP      W4,#2
0E32:  BRA     NZ,E46
.................... 			output_low(IN1);     
0E34:  BCLR.B  2C4.0
.................... 			output_high(IN2); 
0E36:  BSET.B  2C4.1
.................... 			output_low(IN3); 
0E38:  BCLR.B  2C4.2
.................... 			output_high(IN4); 
0E3A:  BSET.B  2C4.4
.................... 			set_pwm_duty(1, speed); 
0E3C:  PUSH    8A6
0E3E:  POP     180
.................... 			set_pwm_duty(2, speed);		 
0E40:  PUSH    8A6
0E42:  POP     186
.................... 		} 
0E44:  BRA     E5C
.................... 		else if(direction == PLUS){	 
0E46:  MOV     8A4,W4
0E48:  CP      W4,#1
0E4A:  BRA     NZ,E5C
.................... 			output_high(IN1);     
0E4C:  BSET.B  2C4.0
.................... 			output_low(IN2);	     
0E4E:  BCLR.B  2C4.1
.................... 			output_high(IN3); 
0E50:  BSET.B  2C4.2
.................... 			output_low(IN4); 
0E52:  BCLR.B  2C4.4
.................... 			set_pwm_duty(1, speed); 
0E54:  PUSH    8A6
0E56:  POP     180
.................... 			set_pwm_duty(2, speed); 
0E58:  PUSH    8A6
0E5A:  POP     186
.................... 		} 
.................... 	} 
0E5C:  BRA     E92
....................  
.................... 	else if(axis == Yaxis){ 
0E5E:  MOV     8A2,W4
0E60:  CP      W4,#1
0E62:  BRA     NZ,E92
.................... 		if(direction == PLUS){ 
0E64:  MOV     8A4,W4
0E66:  CP      W4,#1
0E68:  BRA     NZ,E7C
.................... 			output_low(IN1); 
0E6A:  BCLR.B  2C4.0
.................... 			output_high(IN2); 
0E6C:  BSET.B  2C4.1
.................... 			output_high(IN3); 
0E6E:  BSET.B  2C4.2
.................... 			output_low(IN4); 
0E70:  BCLR.B  2C4.4
.................... 			set_pwm_duty(1, speed); 
0E72:  PUSH    8A6
0E74:  POP     180
.................... 			set_pwm_duty(2, speed); 
0E76:  PUSH    8A6
0E78:  POP     186
.................... 		} 
0E7A:  BRA     E92
.................... 		else if(direction == MINUS){ 
0E7C:  MOV     8A4,W4
0E7E:  CP      W4,#2
0E80:  BRA     NZ,E92
.................... 			output_high(IN1); 
0E82:  BSET.B  2C4.0
.................... 			output_low(IN2); 
0E84:  BCLR.B  2C4.1
.................... 			output_low(IN3); 
0E86:  BCLR.B  2C4.2
.................... 			output_high(IN4); 
0E88:  BSET.B  2C4.4
.................... 			set_pwm_duty(1, speed); 
0E8A:  PUSH    8A6
0E8C:  POP     180
.................... 			set_pwm_duty(2, speed); 
0E8E:  PUSH    8A6
0E90:  POP     186
.................... 		}	 
.................... 	}	 
0E92:  RETURN  
.................... } 
....................  
.................... void control_position(int axis, float target, float currentPosition) { 
*
1826:  MOV     W5,[W15++]
1828:  MOV     W6,[W15++]
.................... 	if(axis == Xaxis){ 
182A:  CP0     87E
182C:  BRA     NZ,195E
.................... 		Kp = 4; 
182E:  CLR     808
1830:  MOV     #4080,W4
1832:  MOV     W4,80A
.................... 		Ki = 0.00000001; 
1834:  MOV     #CC77,W4
1836:  MOV     W4,810
1838:  MOV     #322B,W4
183A:  MOV     W4,812
.................... 		Kd = 2; 
183C:  CLR     818
183E:  MOV     #4000,W4
1840:  MOV     W4,81A
.................... 		 
.................... 		e = target - currentPosition; 
1842:  BSET.B  43.0
1844:  MOV     880,W0
1846:  MOV     882,W1
1848:  MOV     884,W2
184A:  MOV     886,W3
184C:  CALL    15CA
1850:  CALL    14A8
1854:  MOV     W0,820
.................... 		int_e = int_e + e; 
1856:  MOV     820,W0
1858:  CALL    1774
185C:  BCLR.B  43.0
185E:  MOV     W0,W2
1860:  MOV     W1,W3
1862:  MOV     824,W0
1864:  MOV     826,W1
1866:  CALL    15CA
186A:  MOV     W0,824
186C:  MOV     W1,826
.................... 		u = Kp*e + Ki*int_e + Kd*(e-p_e); 
186E:  MOV     820,W0
1870:  CALL    1774
1874:  MOV     W0,W2
1876:  MOV     W1,W3
1878:  MOV     808,W0
187A:  MOV     80A,W1
187C:  CALL    131A
1880:  MOV     W0,W5
1882:  MOV     W1,W6
1884:  MOV     810,W0
1886:  MOV     812,W1
1888:  MOV     824,W2
188A:  MOV     826,W3
188C:  CALL    131A
1890:  BCLR.B  43.0
1892:  MOV     W0,W2
1894:  MOV     W1,W3
1896:  MOV     W5,W0
1898:  MOV     W6,W1
189A:  CALL    15CA
189E:  MOV     W0,W5
18A0:  MOV     W1,W6
18A2:  MOV     820,W0
18A4:  CALL    1774
18A8:  BSET.B  43.0
18AA:  MOV     83C,W2
18AC:  MOV     83E,W3
18AE:  CALL    15CA
18B2:  MOV     W0,W2
18B4:  MOV     W1,W3
18B6:  MOV     818,W0
18B8:  MOV     81A,W1
18BA:  CALL    131A
18BE:  BCLR.B  43.0
18C0:  MOV     W0,W2
18C2:  MOV     W1,W3
18C4:  MOV     W5,W0
18C6:  MOV     W6,W1
18C8:  CALL    15CA
18CC:  MOV     W0,82C
18CE:  MOV     W1,82E
.................... 		p_e = e;   
18D0:  MOV     820,W0
18D2:  CALL    1774
18D6:  MOV     W0,83C
18D8:  MOV     W1,83E
.................... 		 
.................... 		if (abs(e)>tor){ 
18DA:  MOV     820,W0
18DC:  BTSS    W0.F
18DE:  BRA     18E6
18E0:  MOV     #0,W4
18E2:  MOV     820,W3
18E4:  SUB     W4,W3,W0
18E6:  MOV     W0,W5
18E8:  MOV     W5,W0
18EA:  CALL    1774
18EE:  MOV     W0,W2
18F0:  MOV     W1,W3
18F2:  MOV     844,W0
18F4:  MOV     846,W1
18F6:  CALL    17BE
18FA:  BRA     NC,191C
.................... 			if(u > 255){ 
18FC:  MOV     #0,W0
18FE:  MOV     #437F,W1
1900:  MOV     82C,W2
1902:  MOV     82E,W3
1904:  CALL    17BE
1908:  BRA     NC,1912
.................... 				control = 255;	 
190A:  CLR     834
190C:  MOV     #437F,W4
190E:  MOV     W4,836
.................... 			} 
1910:  BRA     191C
.................... 			else{ 
.................... 				control = abs(u); 
1912:  MOV     82C,W0
1914:  MOV     82E,W1
1916:  BCLR    W1.F
1918:  MOV     W0,834
191A:  MOV     W1,836
.................... 			} 
.................... 		} 
.................... 		if (u>0){ 
191C:  MOV     #0,W0
191E:  MOV     #0,W1
1920:  MOV     82C,W2
1922:  MOV     82E,W3
1924:  CALL    17BE
1928:  BRA     NC,1944
.................... 			drive_motor(axis,PLUS,control); 
192A:  MOV     834,W0
192C:  MOV     836,W1
192E:  CALL    14A8
1932:  MOV     W0,W5
1934:  PUSH    87E
1936:  POP     8A2
1938:  MOV     #1,W4
193A:  MOV     W4,8A4
193C:  MOV     W5,8A6
193E:  CALL    E1C
.................... 		} 
1942:  BRA     195C
.................... 		else{ 
.................... 			drive_motor(axis,MINUS,control); 
1944:  MOV     834,W0
1946:  MOV     836,W1
1948:  CALL    14A8
194C:  MOV     W0,W5
194E:  PUSH    87E
1950:  POP     8A2
1952:  MOV     #2,W4
1954:  MOV     W4,8A4
1956:  MOV     W5,8A6
1958:  CALL    E1C
.................... 		} 
.................... 	} 
195C:  BRA     1A94
.................... 	else if(axis == Yaxis){ 
195E:  MOV     87E,W4
1960:  CP      W4,#1
1962:  BRA     NZ,1A94
.................... 		Kp_2 = 1.99521; 
1964:  MOV     #630B,W4
1966:  MOV     W4,80C
1968:  MOV     #3FFF,W4
196A:  MOV     W4,80E
.................... 		Ki_2 = 0.00001; 
196C:  MOV     #C5AC,W4
196E:  MOV     W4,814
1970:  MOV     #3727,W4
1972:  MOV     W4,816
.................... 		Kd_2 = 1.5; 
1974:  CLR     81C
1976:  MOV     #3FC0,W4
1978:  MOV     W4,81E
.................... 		 
.................... 		e_2 = target - currentPosition; 
197A:  BSET.B  43.0
197C:  MOV     880,W0
197E:  MOV     882,W1
1980:  MOV     884,W2
1982:  MOV     886,W3
1984:  CALL    15CA
1988:  CALL    14A8
198C:  MOV     W0,822
.................... 		int_e_2 = int_e_2 + e_2; 
198E:  MOV     822,W0
1990:  CALL    1774
1994:  BCLR.B  43.0
1996:  MOV     W0,W2
1998:  MOV     W1,W3
199A:  MOV     828,W0
199C:  MOV     82A,W1
199E:  CALL    15CA
19A2:  MOV     W0,828
19A4:  MOV     W1,82A
.................... 		u_2 = Kp_2*e_2 + Ki_2*int_e_2 + Kd_2*(e_2-p_e_2); 
19A6:  MOV     822,W0
19A8:  CALL    1774
19AC:  MOV     W0,W2
19AE:  MOV     W1,W3
19B0:  MOV     80C,W0
19B2:  MOV     80E,W1
19B4:  CALL    131A
19B8:  MOV     W0,W5
19BA:  MOV     W1,W6
19BC:  MOV     814,W0
19BE:  MOV     816,W1
19C0:  MOV     828,W2
19C2:  MOV     82A,W3
19C4:  CALL    131A
19C8:  BCLR.B  43.0
19CA:  MOV     W0,W2
19CC:  MOV     W1,W3
19CE:  MOV     W5,W0
19D0:  MOV     W6,W1
19D2:  CALL    15CA
19D6:  MOV     W0,W5
19D8:  MOV     W1,W6
19DA:  MOV     822,W0
19DC:  CALL    1774
19E0:  BSET.B  43.0
19E2:  MOV     840,W2
19E4:  MOV     842,W3
19E6:  CALL    15CA
19EA:  MOV     W0,W2
19EC:  MOV     W1,W3
19EE:  MOV     81C,W0
19F0:  MOV     81E,W1
19F2:  CALL    131A
19F6:  BCLR.B  43.0
19F8:  MOV     W0,W2
19FA:  MOV     W1,W3
19FC:  MOV     W5,W0
19FE:  MOV     W6,W1
1A00:  CALL    15CA
1A04:  MOV     W0,830
1A06:  MOV     W1,832
.................... 		p_e_2 = e_2;   
1A08:  MOV     822,W0
1A0A:  CALL    1774
1A0E:  MOV     W0,840
1A10:  MOV     W1,842
.................... 		 
.................... 		if (abs(e_2)>tor){ 
1A12:  MOV     822,W0
1A14:  BTSS    W0.F
1A16:  BRA     1A1E
1A18:  MOV     #0,W4
1A1A:  MOV     822,W3
1A1C:  SUB     W4,W3,W0
1A1E:  MOV     W0,W5
1A20:  MOV     W5,W0
1A22:  CALL    1774
1A26:  MOV     W0,W2
1A28:  MOV     W1,W3
1A2A:  MOV     844,W0
1A2C:  MOV     846,W1
1A2E:  CALL    17BE
1A32:  BRA     NC,1A54
.................... 			if(u_2 > 255){ 
1A34:  MOV     #0,W0
1A36:  MOV     #437F,W1
1A38:  MOV     830,W2
1A3A:  MOV     832,W3
1A3C:  CALL    17BE
1A40:  BRA     NC,1A4A
.................... 				control_2 = 255;	 
1A42:  CLR     838
1A44:  MOV     #437F,W4
1A46:  MOV     W4,83A
.................... 			} 
1A48:  BRA     1A54
.................... 			else{ 
.................... 				control_2 = abs(u_2); 
1A4A:  MOV     830,W0
1A4C:  MOV     832,W1
1A4E:  BCLR    W1.F
1A50:  MOV     W0,838
1A52:  MOV     W1,83A
.................... 			} 
.................... 		} 
.................... 		if (u_2>0){ 
1A54:  MOV     #0,W0
1A56:  MOV     #0,W1
1A58:  MOV     830,W2
1A5A:  MOV     832,W3
1A5C:  CALL    17BE
1A60:  BRA     NC,1A7C
.................... 			drive_motor(axis,PLUS,control_2); 
1A62:  MOV     838,W0
1A64:  MOV     83A,W1
1A66:  CALL    14A8
1A6A:  MOV     W0,W5
1A6C:  PUSH    87E
1A6E:  POP     8A2
1A70:  MOV     #1,W4
1A72:  MOV     W4,8A4
1A74:  MOV     W5,8A6
1A76:  CALL    E1C
.................... 		} 
1A7A:  BRA     1A94
.................... 		else{ 
.................... 			drive_motor(axis,MINUS,control_2); 
1A7C:  MOV     838,W0
1A7E:  MOV     83A,W1
1A80:  CALL    14A8
1A84:  MOV     W0,W5
1A86:  PUSH    87E
1A88:  POP     8A2
1A8A:  MOV     #2,W4
1A8C:  MOV     W4,8A4
1A8E:  MOV     W5,8A6
1A90:  CALL    E1C
.................... 		} 
.................... 	} 
1A94:  MOV     [--W15],W6
1A96:  MOV     [--W15],W5
1A98:  RETURN  
.................... } 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             LOCAL FUNCTIONS                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... int main (void) 
*
1E02:  MOV     #2780,W15
1E04:  MOV     #27FF,W0
1E06:  MOV     W0,20
1E08:  NOP     
1E0A:  MOV     #4444,W0
1E0C:  MOV     W0,A4
1E0E:  MOV     #4444,W0
1E10:  MOV     W0,B0
1E12:  BSET.B  81.7
1E14:  MOV     #46,W0
1E16:  MOV.B   W0L,742
1E18:  MOV     #57,W0
1E1A:  MOV.B   W0L,742
1E1C:  BCLR.B  742.6
1E1E:  MOV     #53F,W0
1E20:  MOV     W0,680
1E22:  MOV     #3F04,W0
1E24:  MOV     W0,682
1E26:  MOV     #100,W0
1E28:  MOV     W0,68E
1E2A:  MOV     #302,W0
1E2C:  MOV     W0,690
1E2E:  MOV     #3F0C,W0
1E30:  MOV     W0,6A4
1E32:  MOV     #1312,W0
1E34:  MOV     W0,6C6
1E36:  MOV     #300,W0
1E38:  MOV     W0,6CC
1E3A:  MOV     #46,W0
1E3C:  MOV.B   W0L,742
1E3E:  MOV     #57,W0
1E40:  MOV.B   W0L,742
1E42:  BSET.B  742.6
1E44:  CLR     744
1E46:  MOV     #8000,W4
1E48:  MOV     W4,220
1E4A:  MOV     #400,W4
1E4C:  MOV     W4,222
1E4E:  BSET.B  220.3
1E50:  MOV     #22,W4
1E52:  MOV     W4,228
1E54:  CLR     808
1E56:  CLR     80A
1E58:  CLR     80C
1E5A:  CLR     80E
1E5C:  CLR     810
1E5E:  CLR     812
1E60:  CLR     814
1E62:  CLR     816
1E64:  CLR     818
1E66:  CLR     81A
1E68:  CLR     81C
1E6A:  CLR     81E
1E6C:  CLR     820
1E6E:  CLR     822
1E70:  CLR     824
1E72:  CLR     826
1E74:  CLR     828
1E76:  CLR     82A
1E78:  CLR     82C
1E7A:  CLR     82E
1E7C:  CLR     830
1E7E:  CLR     832
1E80:  CLR     834
1E82:  CLR     836
1E84:  CLR     838
1E86:  CLR     83A
1E88:  CLR     83C
1E8A:  CLR     83E
1E8C:  CLR     840
1E8E:  CLR     842
1E90:  CLR     844
1E92:  MOV     #3F00,W4
1E94:  MOV     W4,846
1E96:  CLR     84A
1E98:  CLR     84C
1E9A:  CLR     84E
1E9C:  CLR     850
1E9E:  CLR     852
1EA0:  CLR     854
1EA2:  CLR     856
1EA4:  CLR     858
1EA6:  MOV     #B4,W4
1EA8:  MOV     W4,85A
1EAA:  CLR     85C
1EAC:  CLR     860
1EAE:  CLR     862
1EB0:  CLR     864
1EB2:  CLR     866
1EB4:  CLR     868
1EB6:  CLR     86A
1EB8:  MOV     #5C29,W4
1EBA:  MOV     W4,876
1EBC:  MOV     #4137,W4
1EBE:  MOV     W4,878
1EC0:  MOV     #1,W4
1EC2:  MOV     W4,87A
*
1EC8:  CLR     744
*
1ECC:  SETM    32C
1ECE:  MOV     #8AA,W4
1ED0:  MOV     W4,806
1ED2:  MOV     #1ED2,W4
1ED4:  MOV     W4,8AA
1ED6:  CLR     8AC
....................  {		 
.................... 	disable_interrupts(INTR_GLOBAL); 
1ED8:  BCLR.B  81.7
1EDA:  MOV     #E0,W4
1EDC:  MOV     W4,42
1EDE:  BSET.B  81.7
.................... 	HardwareInit ();	 
1EE0:  CALL    1D4A
.................... 	enable_interrupts(INTR_GLOBAL); 
1EE4:  BCLR.B  81.7
1EE6:  CLR     42
1EE8:  BSET.B  81.7
.................... 	for (;;) 
.................... 	{ 
1EEA:  BRA     1EEA
.................... 	} 
.................... 	return 0; 
1EEC:  CLR     0
.................... } 
....................  
1EEE:  PWRSAV  #0
.................... static void HardwareInit (void) 
*
1D4A:  MOV     W5,[W15++]
.................... { 
.................... 	setup_adc_ports(NO_ANALOGS); 
1D4C:  SETM    32C
.................... 	set_tris_a (get_tris_a () & 0xffe8); //1111 1111 1110 1000 
1D4E:  MOV     2C0,W5
1D50:  MOV     #FFE8,W0
1D52:  AND     W0,W5,W5
1D54:  MOV     W5,2C0
.................... 	set_tris_b (get_tris_b () & 0xff3f); //1111 1111 0011 1111 
1D56:  MOV     2C8,W5
1D58:  MOV     #FF3F,W0
1D5A:  AND     W0,W5,W5
1D5C:  MOV     W5,2C8
.................... 	B0 = (ReadPortB & 0x0001); 
1D5E:  MOV     86C,W0
1D60:  AND     W0,#1,W0
1D62:  MOV     W0,86E
.................... 	B1 = (ReadPortB & 0x0002) >> 1; 
1D64:  MOV     86C,W0
1D66:  AND     W0,#2,W5
1D68:  MOV     W5,870
1D6A:  LSR     870
.................... 	B2 = (ReadPortB & 0x0004) >> 2; 
1D6C:  MOV     86C,W0
1D6E:  AND     W0,#4,W5
1D70:  MOV     W5,872
1D72:  LSR     872
1D74:  LSR     872
.................... 	B3 = (ReadPortB & 0x0008) >> 3; 
1D76:  MOV     86C,W0
1D78:  AND     W0,#8,W5
1D7A:  MOV     W5,874
1D7C:  LSR     874
1D7E:  LSR     874
1D80:  LSR     874
....................  
.................... 	setup_capture(1,CAPTURE_EE | INTERRUPT_EVERY_CAPTURE |CAPTURE_TIMER2); 
1D82:  MOV     #81,W4
1D84:  MOV     W4,142
.................... 	clear_interrupt(INT_IC1); 
1D86:  BCLR.B  84.1
.................... 	enable_interrupts(INT_IC1); 
1D88:  BSET.B  94.1
.................... 	 
.................... 	setup_capture(2,CAPTURE_EE | INTERRUPT_EVERY_CAPTURE |CAPTURE_TIMER2); 
1D8A:  MOV     #81,W4
1D8C:  MOV     W4,146
.................... 	clear_interrupt(INT_IC2); 
1D8E:  BCLR.B  84.5
.................... 	enable_interrupts(INT_IC2); 
1D90:  BSET.B  94.5
....................  
.................... 	setup_capture(3,CAPTURE_EE | INTERRUPT_EVERY_CAPTURE |CAPTURE_TIMER2); 
1D92:  MOV     #81,W4
1D94:  MOV     W4,14A
.................... 	clear_interrupt(INT_IC3); 
1D96:  BCLR.B  88.5
.................... 	enable_interrupts(INT_IC3); 
1D98:  BSET.B  98.5
....................  
.................... 	setup_capture(4,CAPTURE_EE | INTERRUPT_EVERY_CAPTURE |CAPTURE_TIMER2); 
1D9A:  MOV     #81,W4
1D9C:  MOV     W4,14E
.................... 	clear_interrupt(INT_IC4); 
1D9E:  BCLR.B  88.6
.................... 	enable_interrupts(INT_IC4); 
1DA0:  BSET.B  98.6
....................  
.................... 	clear_interrupt(INT_EXT1); 
1DA2:  BCLR.B  86.4
.................... 	enable_interrupts(INT_EXT1); 
1DA4:  BSET.B  96.4
.................... 	 
.................... 	clear_interrupt(INT_EXT2); 
1DA6:  BCLR.B  87.5
.................... 	enable_interrupts(INT_EXT2); 
1DA8:  BSET.B  97.5
.................... 	 
.................... 	/*clear_interrupt(INT_TIMER1); 
.................... 	enable_interrupts(INT_TIMER1);*/ 
....................  
.................... 	/*clear_interrupt(INT_TIMER4); 
.................... 	enable_interrupts(INT_TIMER4);*/ 
....................  
.................... 	duty1 = START_DUTY; 
1DAA:  CLR     848
.................... 	set_compare_time(1, duty1, duty1); 
1DAC:  PUSH    848
1DAE:  POP     182
1DB0:  PUSH    848
1DB2:  POP     180
.................... 	setup_compare(1, COMPARE_PWM | COMPARE_TIMER3); 
1DB4:  MOV     #E,W4
1DB6:  MOV     W4,184
....................  
.................... 	set_compare_time(2, duty1, duty1); 
1DB8:  PUSH    848
1DBA:  POP     188
1DBC:  PUSH    848
1DBE:  POP     186
.................... 	setup_compare(2, COMPARE_PWM | COMPARE_TIMER3); 
1DC0:  MOV     #E,W4
1DC2:  MOV     W4,18A
.................... 	 
.................... 	set_timer1(0); 
1DC4:  CLR     100
.................... 	setup_timer1(TMR_INTERNAL | TMR_DIV_BY_256, 6249); 	 
1DC6:  CLR     104
1DC8:  MOV     #1869,W4
1DCA:  MOV     W4,102
1DCC:  MOV     #8030,W4
1DCE:  MOV     W4,104
.................... 	 
.................... 	set_timer2(0); 
1DD0:  CLR     106
.................... 	setup_timer2(TMR_INTERNAL | TMR_DIV_BY_1, 65535); 
1DD2:  CLR     110
1DD4:  SETM    10C
1DD6:  MOV     #8000,W4
1DD8:  MOV     W4,110
....................  
.................... 	set_timer3(0); 
1DDA:  CLR     10A
.................... 	setup_timer3(TMR_INTERNAL | TMR_DIV_BY_1, 400); 
1DDC:  CLR     112
1DDE:  MOV     #190,W4
1DE0:  MOV     W4,10E
1DE2:  MOV     #8000,W4
1DE4:  MOV     W4,112
....................  
.................... 	set_timer4(0); 
1DE6:  CLR     114
.................... 	setup_timer4 (TMR_INTERNAL | TMR_DIV_BY_256, 6249); 
1DE8:  CLR     11E
1DEA:  MOV     #1869,W4
1DEC:  MOV     W4,11A
1DEE:  MOV     #8030,W4
1DF0:  MOV     W4,11E
....................  
.................... 	set_timer5(0); 
1DF2:  CLR     118
.................... 	setup_timer5 (TMR_INTERNAL | TMR_DIV_BY_256, 6249); 
1DF4:  CLR     120
1DF6:  MOV     #1869,W4
1DF8:  MOV     W4,11C
1DFA:  MOV     #8030,W4
1DFC:  MOV     W4,120
.................... 	return; 
1DFE:  MOV     [--W15],W5
1E00:  RETURN  
.................... } 
....................  
.................... #INT_TIMER1 
.................... void Home(void){ 
*
0E94:  PUSH    42
0E96:  PUSH    36
0E98:  PUSH    32
0E9A:  MOV     W0,[W15++]
0E9C:  MOV     #2,W0
0E9E:  REPEAT  #C
0EA0:  MOV     [W0++],[W15++]
.................... 	if(home_state == 1){ 
0EA2:  MOV     87A,W4
0EA4:  CP      W4,#1
0EA6:  BRA     NZ,EB8
.................... 		drive_motor(Xaxis,MINUS,80); 
0EA8:  CLR     8A2
0EAA:  MOV     #2,W4
0EAC:  MOV     W4,8A4
0EAE:  MOV     #50,W4
0EB0:  MOV     W4,8A6
0EB2:  CALL    E1C
.................... 	} 
0EB6:  BRA     ECE
.................... 	else if(home_state == 2){ 
0EB8:  MOV     87A,W4
0EBA:  CP      W4,#2
0EBC:  BRA     NZ,ECE
.................... 		drive_motor(Yaxis,PLUS,80); 
0EBE:  MOV     #1,W4
0EC0:  MOV     W4,8A2
0EC2:  MOV     #1,W4
0EC4:  MOV     W4,8A4
0EC6:  MOV     #50,W4
0EC8:  MOV     W4,8A6
0ECA:  CALL    E1C
.................... 	} 
.................... 	return; 
.................... } 
....................  
0ECE:  BCLR.B  84.3
0ED0:  MOV     #1A,W0
0ED2:  REPEAT  #C
0ED4:  MOV     [--W15],[W0--]
0ED6:  MOV     [--W15],W0
0ED8:  POP     32
0EDA:  POP     36
0EDC:  POP     42
0EDE:  RETFIE  
.................... #INT_EXT1 
.................... void Initial_X_axis(void){ 
0EE0:  PUSH    42
0EE2:  PUSH    36
0EE4:  PUSH    32
0EE6:  MOV     W0,[W15++]
0EE8:  MOV     #2,W0
0EEA:  REPEAT  #C
0EEC:  MOV     [W0++],[W15++]
.................... 	/*thetaX = (count_pulseX*7.5)/64; 
.................... 	thetaY = (count_pulseY*7.5)/64; 
.................... 	current_posX = (thetaX*(22/7)*radius)/180; 
.................... 	current_posY = (thetaY*(22/7)*radius)/180; 
.................... 	int h = thetaX; 
.................... 	printf("\ncurrent_posX = %d",h); 
.................... 	control_position(Xaxis, 360 , thetaX);*/ 
.................... 	clear_interrupt(INT_TIMER4); 
0EEE:  BCLR.B  87.3
.................... 	enable_interrupts(INT_TIMER4); 
0EF0:  BSET.B  97.3
....................  
.................... 	/*int_e = 0; 
.................... 	count_pulseX = 0; 
.................... 	current_posX = 0; 
.................... 	drive_motor(Xaxis,MINUS,0); 
.................... 	printf("InitialX"); 
.................... 	home_state =  2;*/ 
.................... 	return; 
.................... } 
....................  
0EF2:  BCLR.B  86.4
0EF4:  MOV     #1A,W0
0EF6:  REPEAT  #C
0EF8:  MOV     [--W15],[W0--]
0EFA:  MOV     [--W15],W0
0EFC:  POP     32
0EFE:  POP     36
0F00:  POP     42
0F02:  RETFIE  
.................... #INT_EXT2 
.................... void Initial_Y_axis(void){ 
0F04:  PUSH    42
0F06:  PUSH    36
0F08:  PUSH    32
0F0A:  MOV     W0,[W15++]
0F0C:  MOV     #2,W0
0F0E:  REPEAT  #C
0F10:  MOV     [W0++],[W15++]
.................... 	/*thetaX = (count_pulseX*7.5)/64; 
.................... 	thetaY = (count_pulseY*7.5)/64; 
.................... 	current_posX = (thetaX*(22/7)*radius)/180; 
.................... 	current_posY = (thetaY*(22/7)*radius)/180; 
.................... 	int h = thetaX; 
.................... 	printf("\ncurrent_posX = %d",h); 
.................... 	control_position(Xaxis, -360 , thetaX);*/ 
....................  
.................... 	clear_interrupt(INT_TIMER5); 
0F12:  BCLR.B  87.4
.................... 	enable_interrupts(INT_TIMER5); 
0F14:  BSET.B  97.4
.................... 	/*int_e_2 = 0; 
.................... 	count_pulseY = 0; 
.................... 	current_posY = 0; 
.................... 	drive_motor(Yaxis,MINUS,0);  
.................... 	printf("InitialY"); 
.................... 	home_state = 0; 
.................... 	drive_motor(Xaxis,MINUS,0); 
.................... 	disable_interrupts(INT_TIMER1); 
.................... 	clear_interrupt(INT_TIMER4); 
.................... 	enable_interrupts(INT_TIMER4);	*/ 
.................... 	return; 
.................... }	 
....................  
0F16:  BCLR.B  87.5
0F18:  MOV     #1A,W0
0F1A:  REPEAT  #C
0F1C:  MOV     [--W15],[W0--]
0F1E:  MOV     [--W15],W0
0F20:  POP     32
0F22:  POP     36
0F24:  POP     42
0F26:  RETFIE  
.................... #INT_IC1 
.................... void Encoder1_A(void){ 
0F28:  PUSH    42
0F2A:  PUSH    36
0F2C:  PUSH    32
0F2E:  MOV     W0,[W15++]
0F30:  MOV     #2,W0
0F32:  REPEAT  #C
0F34:  MOV     [W0++],[W15++]
.................... 	ReadPortB = input_b() & 0x0003;   
0F36:  MOV     2CA,W5
0F38:  AND     W5,#3,W0
0F3A:  MOV     W0,86C
.................... 	B0 = (ReadPortB & 0x0001); 
0F3C:  MOV     86C,W0
0F3E:  AND     W0,#1,W0
0F40:  MOV     W0,86E
.................... 	if((B0 ^ B1) == 0){ 
0F42:  MOV     86E,W0
0F44:  XOR     870,W0
0F46:  MOV     W0,W5
0F48:  CP0     W5
0F4A:  BRA     NZ,F54
.................... 		count_pulseX--; 
0F4C:  DEC     084A
0F4E:  BTSS.B  42.0
0F50:  DEC     084C
.................... 	} 
0F52:  BRA     F5A
.................... 	else{ 
.................... 		count_pulseX++; 
0F54:  INC     084A
0F56:  BTSC.B  42.1
0F58:  INC     084C
.................... 	} 
.................... 	//printf("\ncount_pulseX = %d",count_pulseX); 
.................... 	return; 
.................... } 
....................  
0F5A:  BCLR.B  84.1
0F5C:  MOV     #1A,W0
0F5E:  REPEAT  #C
0F60:  MOV     [--W15],[W0--]
0F62:  MOV     [--W15],W0
0F64:  POP     32
0F66:  POP     36
0F68:  POP     42
0F6A:  RETFIE  
.................... #INT_IC2 
.................... void Encoder1_B(void){ 
0F6C:  PUSH    42
0F6E:  PUSH    36
0F70:  PUSH    32
0F72:  MOV     W0,[W15++]
0F74:  MOV     #2,W0
0F76:  REPEAT  #C
0F78:  MOV     [W0++],[W15++]
.................... 	ReadPortB = input_b() & 0x0003;   
0F7A:  MOV     2CA,W5
0F7C:  AND     W5,#3,W0
0F7E:  MOV     W0,86C
.................... 	B1 = (ReadPortB & 0x0002 ) >> 1; 
0F80:  MOV     86C,W0
0F82:  AND     W0,#2,W5
0F84:  MOV     W5,870
0F86:  LSR     870
.................... 	if((B0 ^ B1) == 0){ 
0F88:  MOV     86E,W0
0F8A:  XOR     870,W0
0F8C:  MOV     W0,W5
0F8E:  CP0     W5
0F90:  BRA     NZ,F9A
.................... 		count_pulseX++; 
0F92:  INC     084A
0F94:  BTSC.B  42.1
0F96:  INC     084C
.................... 	} 
0F98:  BRA     FA0
.................... 	else{ 
.................... 		count_pulseX--; 
0F9A:  DEC     084A
0F9C:  BTSS.B  42.0
0F9E:  DEC     084C
.................... 	} 
.................... 	//printf("\ncount_pulseX = %d",count_pulseX); 
.................... 	return; 
.................... } 
.................... 	 
0FA0:  BCLR.B  84.5
0FA2:  MOV     #1A,W0
0FA4:  REPEAT  #C
0FA6:  MOV     [--W15],[W0--]
0FA8:  MOV     [--W15],W0
0FAA:  POP     32
0FAC:  POP     36
0FAE:  POP     42
0FB0:  RETFIE  
.................... #INT_IC3 
.................... void Encoder2_A(void){ 
0FB2:  PUSH    42
0FB4:  PUSH    36
0FB6:  PUSH    32
0FB8:  MOV     W0,[W15++]
0FBA:  MOV     #2,W0
0FBC:  REPEAT  #C
0FBE:  MOV     [W0++],[W15++]
.................... 	ReadPortB = input_b() & 0x000c;  
0FC0:  MOV     2CA,W5
0FC2:  AND     W5,#C,W0
0FC4:  MOV     W0,86C
.................... 	B2 = (ReadPortB & 0x0004) >> 2;  
0FC6:  MOV     86C,W0
0FC8:  AND     W0,#4,W5
0FCA:  MOV     W5,872
0FCC:  LSR     872
0FCE:  LSR     872
.................... 	B3 = (ReadPortB & 0x0008) >> 3; 
0FD0:  MOV     86C,W0
0FD2:  AND     W0,#8,W5
0FD4:  MOV     W5,874
0FD6:  LSR     874
0FD8:  LSR     874
0FDA:  LSR     874
.................... 	if((B2 ^ B3) == 0){ 
0FDC:  MOV     872,W0
0FDE:  XOR     874,W0
0FE0:  MOV     W0,W5
0FE2:  CP0     W5
0FE4:  BRA     NZ,FEE
.................... 		count_pulseY--; 
0FE6:  DEC     084E
0FE8:  BTSS.B  42.0
0FEA:  DEC     0850
.................... 	} 
0FEC:  BRA     FF4
.................... 	else{ 
.................... 		count_pulseY++; 
0FEE:  INC     084E
0FF0:  BTSC.B  42.1
0FF2:  INC     0850
.................... 	} 
.................... 	//printf("\ncount_pulseY = %d",count_pulseY); 
.................... 	return; 
.................... } 
....................  
0FF4:  BCLR.B  88.5
0FF6:  MOV     #1A,W0
0FF8:  REPEAT  #C
0FFA:  MOV     [--W15],[W0--]
0FFC:  MOV     [--W15],W0
0FFE:  POP     32
1000:  POP     36
1002:  POP     42
1004:  RETFIE  
.................... #INT_IC4 
.................... void Encoder2_B(void){ 
1006:  PUSH    42
1008:  PUSH    36
100A:  PUSH    32
100C:  MOV     W0,[W15++]
100E:  MOV     #2,W0
1010:  REPEAT  #C
1012:  MOV     [W0++],[W15++]
.................... 	ReadPortB = input_b() & 0x000c;   
1014:  MOV     2CA,W5
1016:  AND     W5,#C,W0
1018:  MOV     W0,86C
.................... 	B2 = (ReadPortB & 0x0004) >> 2; 
101A:  MOV     86C,W0
101C:  AND     W0,#4,W5
101E:  MOV     W5,872
1020:  LSR     872
1022:  LSR     872
.................... 	B3 = (ReadPortB & 0x0008) >> 3; 
1024:  MOV     86C,W0
1026:  AND     W0,#8,W5
1028:  MOV     W5,874
102A:  LSR     874
102C:  LSR     874
102E:  LSR     874
.................... 	if((B2 ^ B3) == 0){ 
1030:  MOV     872,W0
1032:  XOR     874,W0
1034:  MOV     W0,W5
1036:  CP0     W5
1038:  BRA     NZ,1042
.................... 		count_pulseY++; 
103A:  INC     084E
103C:  BTSC.B  42.1
103E:  INC     0850
.................... 	} 
1040:  BRA     1048
.................... 	else{ 
.................... 		count_pulseY--; 
1042:  DEC     084E
1044:  BTSS.B  42.0
1046:  DEC     0850
.................... 	} 
.................... 	//printf("\ncount_pulseY = %d",count_pulseY); 
.................... 	return; 
.................... } 
....................  
1048:  BCLR.B  88.6
104A:  MOV     #1A,W0
104C:  REPEAT  #C
104E:  MOV     [--W15],[W0--]
1050:  MOV     [--W15],W0
1052:  POP     32
1054:  POP     36
1056:  POP     42
1058:  RETFIE  
.................... #INT_TIMER4 
.................... void Run_Motor(void){ 
*
1A9A:  PUSH    42
1A9C:  PUSH    36
1A9E:  PUSH    32
1AA0:  MOV     W0,[W15++]
1AA2:  MOV     #2,W0
1AA4:  REPEAT  #C
1AA6:  MOV     [W0++],[W15++]
.................... 	thetaX = (count_pulseX*7.5)/64; 
1AA8:  MOV     84A,W0
1AAA:  MOV     84C,W1
1AAC:  CLR     W3
1AAE:  BTSC    W1.F
1AB0:  SETM    W3
1AB2:  MOV     W3,W2
1AB4:  CALL    105A
1AB8:  MOV     #0,W4
1ABA:  MOV     #0,W5
1ABC:  MOV     #0,W6
1ABE:  MOV     #401E,W7
1AC0:  CALL    10BE
1AC4:  MOV     W0,W5
1AC6:  MOV     W1,W6
1AC8:  MOV     W2,W7
1ACA:  MOV     W3,W8
1ACC:  MOV     W5,[W15++]
1ACE:  MOV     W6,[W15++]
1AD0:  MOV     W7,[W15++]
1AD2:  MOV     W5,W0
1AD4:  MOV     W6,W1
1AD6:  MOV     W7,W2
1AD8:  MOV     W8,W3
1ADA:  MOV     #0,W4
1ADC:  MOV     #0,W5
1ADE:  MOV     #0,W6
1AE0:  MOV     #4050,W7
1AE2:  CALL    11CE
1AE6:  MOV     [--W15],W7
1AE8:  MOV     [--W15],W6
1AEA:  MOV     [--W15],W5
1AEC:  CALL    12D6
1AF0:  MOV     W1,852
1AF2:  MOV     W2,854
.................... 	thetaY = (count_pulseY*7.5)/64; 
1AF4:  MOV     84E,W0
1AF6:  MOV     850,W1
1AF8:  CLR     W3
1AFA:  BTSC    W1.F
1AFC:  SETM    W3
1AFE:  MOV     W3,W2
1B00:  CALL    105A
1B04:  MOV     #0,W4
1B06:  MOV     #0,W5
1B08:  MOV     #0,W6
1B0A:  MOV     #401E,W7
1B0C:  CALL    10BE
1B10:  MOV     W0,W5
1B12:  MOV     W1,W6
1B14:  MOV     W2,W7
1B16:  MOV     W3,W8
1B18:  MOV     W5,[W15++]
1B1A:  MOV     W6,[W15++]
1B1C:  MOV     W7,[W15++]
1B1E:  MOV     W5,W0
1B20:  MOV     W6,W1
1B22:  MOV     W7,W2
1B24:  MOV     W8,W3
1B26:  MOV     #0,W4
1B28:  MOV     #0,W5
1B2A:  MOV     #0,W6
1B2C:  MOV     #4050,W7
1B2E:  CALL    11CE
1B32:  MOV     [--W15],W7
1B34:  MOV     [--W15],W6
1B36:  MOV     [--W15],W5
1B38:  CALL    12D6
1B3C:  MOV     W1,856
1B3E:  MOV     W2,858
.................... 	current_posX = (thetaX*(22/7)*radius)/180; 
1B40:  MOV     852,W0
1B42:  MOV     854,W1
1B44:  MOV     #0,W2
1B46:  MOV     #4040,W3
1B48:  CALL    131A
1B4C:  MOV     W0,W5
1B4E:  MOV     W1,W6
1B50:  MOV     W5,W0
1B52:  MOV     W6,W1
1B54:  MOV     876,W2
1B56:  MOV     878,W3
1B58:  CALL    131A
1B5C:  MOV     W0,W5
1B5E:  MOV     W1,W6
1B60:  MOV     W5,W0
1B62:  MOV     W6,W1
1B64:  MOV     #0,W2
1B66:  MOV     #4334,W3
1B68:  CALL    13DE
1B6C:  MOV     W0,860
1B6E:  MOV     W1,862
.................... 	current_posY = (thetaY*(22/7)*radius)/180; 
1B70:  MOV     856,W0
1B72:  MOV     858,W1
1B74:  MOV     #0,W2
1B76:  MOV     #4040,W3
1B78:  CALL    131A
1B7C:  MOV     W0,W5
1B7E:  MOV     W1,W6
1B80:  MOV     W5,W0
1B82:  MOV     W6,W1
1B84:  MOV     876,W2
1B86:  MOV     878,W3
1B88:  CALL    131A
1B8C:  MOV     W0,W5
1B8E:  MOV     W1,W6
1B90:  MOV     W5,W0
1B92:  MOV     W6,W1
1B94:  MOV     #0,W2
1B96:  MOV     #4334,W3
1B98:  CALL    13DE
1B9C:  MOV     W0,864
1B9E:  MOV     W1,866
.................... 	int h = thetaX; 
1BA0:  MOV     852,W0
1BA2:  MOV     854,W1
1BA4:  CALL    14A8
1BA8:  MOV     W0,87C
.................... 	printf("\ncurrent_posX = %d",h); 
1BAA:  MOV     #0,W1
1BAC:  MOV     W1,W0
1BAE:  CLR.B   1
1BB0:  CALL    DFC
1BB4:  INC     W1,W1
1BB6:  BTSC.B  223.1
1BB8:  BRA     1BB6
1BBA:  MOV     W0,224
1BBC:  MOV     #F,W0
1BBE:  CPSGT   W1,W0
1BC0:  BRA     1BAC
1BC2:  MOV     87C,W0
1BC4:  MOV     #0,W4
1BC6:  CALL    14D4
.................... 	//current_pos_show = (current_posX*(22/7)) * radius * 10; 
.................... 	//control_position(Yaxis, target_posY, current_posY); 
.................... 	control_position(Xaxis, 180 , thetaX); 
1BCA:  CLR     87E
1BCC:  CLR     880
1BCE:  MOV     #4334,W4
1BD0:  MOV     W4,882
1BD2:  PUSH    852
1BD4:  POP     884
1BD6:  PUSH    854
1BD8:  POP     886
1BDA:  CALL    1826
.................... 	//drive_motor(Yaxis,MINUS,100); 
.................... 	disable_interrupts(INT_TIMER5); 
1BDE:  BCLR.B  97.4
.................... 	return; 
.................... } 
....................  
1BE0:  BCLR.B  87.3
1BE2:  MOV     #1A,W0
1BE4:  REPEAT  #C
1BE6:  MOV     [--W15],[W0--]
1BE8:  MOV     [--W15],W0
1BEA:  POP     32
1BEC:  POP     36
1BEE:  POP     42
1BF0:  RETFIE  
.................... #INT_TIMER5 
.................... void Run_Motor2(void){ 
1BF2:  PUSH    42
1BF4:  PUSH    36
1BF6:  PUSH    32
1BF8:  MOV     W0,[W15++]
1BFA:  MOV     #2,W0
1BFC:  REPEAT  #C
1BFE:  MOV     [W0++],[W15++]
.................... 	thetaX = (count_pulseX*7.5)/64; 
1C00:  MOV     84A,W0
1C02:  MOV     84C,W1
1C04:  CLR     W3
1C06:  BTSC    W1.F
1C08:  SETM    W3
1C0A:  MOV     W3,W2
1C0C:  CALL    105A
1C10:  MOV     #0,W4
1C12:  MOV     #0,W5
1C14:  MOV     #0,W6
1C16:  MOV     #401E,W7
1C18:  CALL    10BE
1C1C:  MOV     W0,W5
1C1E:  MOV     W1,W6
1C20:  MOV     W2,W7
1C22:  MOV     W3,W8
1C24:  MOV     W5,[W15++]
1C26:  MOV     W6,[W15++]
1C28:  MOV     W7,[W15++]
1C2A:  MOV     W5,W0
1C2C:  MOV     W6,W1
1C2E:  MOV     W7,W2
1C30:  MOV     W8,W3
1C32:  MOV     #0,W4
1C34:  MOV     #0,W5
1C36:  MOV     #0,W6
1C38:  MOV     #4050,W7
1C3A:  CALL    11CE
1C3E:  MOV     [--W15],W7
1C40:  MOV     [--W15],W6
1C42:  MOV     [--W15],W5
1C44:  CALL    12D6
1C48:  MOV     W1,852
1C4A:  MOV     W2,854
.................... 	thetaY = (count_pulseY*7.5)/64; 
1C4C:  MOV     84E,W0
1C4E:  MOV     850,W1
1C50:  CLR     W3
1C52:  BTSC    W1.F
1C54:  SETM    W3
1C56:  MOV     W3,W2
1C58:  CALL    105A
1C5C:  MOV     #0,W4
1C5E:  MOV     #0,W5
1C60:  MOV     #0,W6
1C62:  MOV     #401E,W7
1C64:  CALL    10BE
1C68:  MOV     W0,W5
1C6A:  MOV     W1,W6
1C6C:  MOV     W2,W7
1C6E:  MOV     W3,W8
1C70:  MOV     W5,[W15++]
1C72:  MOV     W6,[W15++]
1C74:  MOV     W7,[W15++]
1C76:  MOV     W5,W0
1C78:  MOV     W6,W1
1C7A:  MOV     W7,W2
1C7C:  MOV     W8,W3
1C7E:  MOV     #0,W4
1C80:  MOV     #0,W5
1C82:  MOV     #0,W6
1C84:  MOV     #4050,W7
1C86:  CALL    11CE
1C8A:  MOV     [--W15],W7
1C8C:  MOV     [--W15],W6
1C8E:  MOV     [--W15],W5
1C90:  CALL    12D6
1C94:  MOV     W1,856
1C96:  MOV     W2,858
.................... 	current_posX = (thetaX*(22/7)*radius)/180; 
1C98:  MOV     852,W0
1C9A:  MOV     854,W1
1C9C:  MOV     #0,W2
1C9E:  MOV     #4040,W3
1CA0:  CALL    131A
1CA4:  MOV     W0,W5
1CA6:  MOV     W1,W6
1CA8:  MOV     W5,W0
1CAA:  MOV     W6,W1
1CAC:  MOV     876,W2
1CAE:  MOV     878,W3
1CB0:  CALL    131A
1CB4:  MOV     W0,W5
1CB6:  MOV     W1,W6
1CB8:  MOV     W5,W0
1CBA:  MOV     W6,W1
1CBC:  MOV     #0,W2
1CBE:  MOV     #4334,W3
1CC0:  CALL    13DE
1CC4:  MOV     W0,860
1CC6:  MOV     W1,862
.................... 	current_posY = (thetaY*(22/7)*radius)/180; 
1CC8:  MOV     856,W0
1CCA:  MOV     858,W1
1CCC:  MOV     #0,W2
1CCE:  MOV     #4040,W3
1CD0:  CALL    131A
1CD4:  MOV     W0,W5
1CD6:  MOV     W1,W6
1CD8:  MOV     W5,W0
1CDA:  MOV     W6,W1
1CDC:  MOV     876,W2
1CDE:  MOV     878,W3
1CE0:  CALL    131A
1CE4:  MOV     W0,W5
1CE6:  MOV     W1,W6
1CE8:  MOV     W5,W0
1CEA:  MOV     W6,W1
1CEC:  MOV     #0,W2
1CEE:  MOV     #4334,W3
1CF0:  CALL    13DE
1CF4:  MOV     W0,864
1CF6:  MOV     W1,866
.................... 	int h = thetaX; 
1CF8:  MOV     852,W0
1CFA:  MOV     854,W1
1CFC:  CALL    14A8
1D00:  MOV     W0,87C
.................... 	printf("\ncurrent_posX = %d",h); 
1D02:  MOV     #0,W1
1D04:  MOV     W1,W0
1D06:  CLR.B   1
1D08:  CALL    DFC
1D0C:  INC     W1,W1
1D0E:  BTSC.B  223.1
1D10:  BRA     1D0E
1D12:  MOV     W0,224
1D14:  MOV     #F,W0
1D16:  CPSGT   W1,W0
1D18:  BRA     1D04
1D1A:  MOV     87C,W0
1D1C:  MOV     #0,W4
1D1E:  CALL    14D4
.................... 	//current_pos_show = (current_posX*(22/7)) * radius * 10; 
.................... 	//control_position(Yaxis, target_posY, current_posY); 
.................... 	control_position(Xaxis, -180 , thetaX); 
1D22:  CLR     87E
1D24:  CLR     880
1D26:  MOV     #C334,W4
1D28:  MOV     W4,882
1D2A:  PUSH    852
1D2C:  POP     884
1D2E:  PUSH    854
1D30:  POP     886
1D32:  CALL    1826
.................... 	//drive_motor(Yaxis,MINUS,100); 
.................... 	disable_interrupts(INT_TIMER4); 
1D36:  BCLR.B  97.3
.................... 	return; 
1D38:  BCLR.B  87.4
1D3A:  MOV     #1A,W0
1D3C:  REPEAT  #C
1D3E:  MOV     [--W15],[W0--]
1D40:  MOV     [--W15],W0
1D42:  POP     32
1D44:  POP     36
1D46:  POP     42
1D48:  RETFIE  
.................... } 
....................  
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                                 EOF                                    **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #import(file="BITWISE_LIB.o") 
.................... /* 
.................... *************************** C SOURCE FILE ************************************ 
....................  
.................... project   : 
.................... filename  : BITWISE_LIB.C 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #define BITWISE_LIB_C_SRC 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             MODULES USED                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #include "BITWISE_LIB.h" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : BITWISE_LIB.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  BITWISE_LIB_INCLUDED 
.................... #define  BITWISE_LIB_INCLUDED 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include "CONFIG_PIC24.H"   
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONFIG_PIC24.H 
.................... version   :  
.................... date      : 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  CONFIG_PIC24_INCLUDED 
.................... #define  CONFIG_PIC24_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include <24FJ48GA002.H> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
....................  
.................... #list 
....................  
.................... //#include <24FJ16GA002.H> 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #DEVICE ADC=10 
.................... #fuses NOIOL1WAY, NODEBUG, NOWRT, NOPROTECT, NOJTAG, NOWDT 
.................... #fuses OSCIO 
.................... #fuses FRC_PLL 
.................... #case 
.................... #type signed 
.................... #use delay(internal=8 MHz, clock = 32000000)  
.................... #use fast_io(ALL) 
.................... #pin_select U1TX = PIN_B13 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232 (UART1, BAUD = 115200, XMIT = PIN_B13, RCV = PIN_B12, STREAM = COM_A) 
.................... #BIT TX1IF = 0x0084.12  // Tx1 Interrupt flag  IFS0.12 
....................  
.................... ////////////////////////////////////////////////// 
.................... // EXT INT pins 
.................... #if 1 
.................... // INT0 is RB7 
.................... #pin_select INT1 = PIN_B5  //Limit Switch1 
.................... #pin_select INT2 = PIN_B4  //Limit Switch2 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... #if 0 
....................  
.................... #pin_select U2TX = PIN_B10 
.................... #pin_select U2RX = PIN_B11 
....................  
.................... //#use RS232 (UART2, BAUD = 9600, XMIT = PIN_B9, RCV = PIN_B8, STREAM = COM_B) 
.................... //#use RS232 (BAUD = 9600, XMIT = PIN_B10, RCV = PIN_B11, STREAM = COM_B) 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... // REMAP i/o pins 
.................... #if 1 
.................... #pin_select OC1 = PIN_B6   //ENA1 
.................... #pin_select OC2 = PIN_B7   //ENA2 
.................... #pin_select IC1 = PIN_B0   //Encoder1_A 
.................... #pin_select IC2 = PIN_B1   //Encoder1_B 
.................... #pin_select IC3 = PIN_B2   //Encoder2_A 
.................... #pin_select IC4 = PIN_B3   //B3 = Encoder2_B 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
....................  
.................... #include <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu\r\n", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include "BL_support.h" 
.................... /******************************************************************************/ 
.................... /* File:    BL_Support.h													  */ 
.................... /* Author:  Dr.Santi Nuratch												  */ 
.................... /*          Embedded Computing and Control Lab., INC-KMUTT 				      */ 
.................... /* Created on 22 September 2016, 13:14										  */ 
.................... /******************************************************************************/ 
....................  
.................... #ifndef BL_SUPPORT_H 
.................... #define	BL_SUPPORT_H 
....................  
.................... /******************************************************************************/ 
.................... /*                   BOOTLOADER SUPPORT CONFIGURATION                         */ 
.................... /*                          (DO NOT CHANGE)                                   */ 
.................... /******************************************************************************/ 
.................... /* Bootloader */ 
.................... #define LOADER_PAGES 	3  
.................... #define ERASE_SIZE 		2048    /* 2048 bytes, 24-bit (3 bytes) per instruction, but it uses 4 bytes aligned --> 4 bytes per word */ 
....................                                 /* each block has 512 instructions (1024 words), each instruction requires 4 bytes (2 words), so 512*4 = 2048 bytes */ 
.................... #define LOADER_SIZE 	((LOADER_PAGES * (ERASE_SIZE/2)) - 1)   /* 2 bytes per address, so divided by 2, 2048/2 = 1024 */  
.................... #define LOADER_END  	LOADER_SIZE                             /* End address      */ 
.................... #define LOADER_ADDR 	0xC00//(LOADER_END - LOADER_SIZE)       /* Start address    */ 
....................  
.................... #build (reset=LOADER_END+1, interrupt=LOADER_END+5) 
.................... #org 0, LOADER_END {}   /* 0x0000 - END */ 
....................  
.................... /******************************************************************************/ 
.................... /*                                  END                                       */ 
.................... /******************************************************************************/ 
....................  
.................... #endif	/* BL_SUPPORT_H */ 
....................  
....................  
.................... /****************************************************************************/ 
.................... // o/p pins  LED 
.................... #define  IN1  PIN_A0 
.................... #define  IN2  PIN_A1   
.................... #define  IN3  PIN_A2   
.................... #define  IN4  PIN_A4   
....................  
.................... // i/p pins  PBSW 
.................... #define  SW0  PIN_B1   //Encoder1B 
.................... #define  SW1  PIN_B3   //Encoder2B 
.................... #define  SW2  PIN_B6 
.................... #define  SW3  PIN_B7 
....................  
.................... // ADC  or  i/o pins if not use ADC 
.................... #define  AX0  PIN_A0 
.................... #define  AX1  PIN_A1 
.................... #define  AX2  PIN_B0  // RP0 remap pin 
.................... #define  AX3  PIN_B1  // RP1 remap pin 
....................  
.................... /****************************************************************************/ 
....................  
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... #include "CDATPIC24.H" 
.................... /* 
.................... ***************************   C DATA TYPE   ******************************* 
.................... **                                                                              
.................... **  project     : C Data Types Extension                                                 
.................... **  filename  : CDATPIC24.H                                                                 
.................... **                                                                                                                
.................... *************************************************************************** 
.................... */ 
....................  
.................... #ifndef   CDATPIC24_INCLUDED 
.................... #define   CDATPIC24_INCLUDED 
....................  
.................... /* 
.................... *************************************************************************** 
....................                             C  TYPEDEFS                                            
.................... *************************************************************************** 
.................... */ 
....................  
.................... /**** C type extensions ****/ 
.................... typedef unsigned char      int8u; 
.................... typedef signed   char      int8s; 
.................... typedef unsigned int       int16u; 
.................... typedef signed   int       int16s; 
.................... typedef unsigned long      int32u; 
.................... typedef signed   long      int32s; 
.................... typedef unsigned long long int64u; 
.................... typedef signed   long long int64s; 
....................  
....................  
.................... #endif 
.................... /* 
.................... ************************************************************************** 
....................                                EOF                                                    
.................... /************************************************************************* 
.................... */ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #ifndef BITWISE_LIB_C_SRC 
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                 Bitwise Library functions (Passed by value) 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                            FUNCTION : BitSet  
.................... // 
.................... // Description : Set a specified bit in 16-bit unsigned data to logic 1, other   
.................... //               bits are not changed 
.................... // Arguments   : "dat"     is the data whose a bit will be set 
.................... //               "bitPos"  is a specified bit position in "dat" which will be set,  
.................... //                            0 <= bitPos <= 15  (bit 0 is LSB, bit 15 is MSB)  
.................... // Returns     : value of "dat" with a bit at position "bitPos" was set to logic 1 
.................... /****************************************************************************/ 
....................  
.................... int16u BitSet (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitClear (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitInvt (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitTest (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
.................... /*****************************************************************************/ 
.................... //                 Bitwise Library functions (Passed by address) 
.................... /*****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                            FUNCTION : BitSetP  
.................... // 
.................... // Description : Set a specified bit in 16-bit unsigned variable to logic 1,    
.................... //               other bits are not changed 
.................... // Arguments   : "datPtr"  is the address of a variable whose a bit will be set 
.................... //               "bitPos"  is a specified bit position in the variable which   
.................... //                         will be set,   0 <= bitPos <= 15   
.................... //                         (bit 0 is LSB, bit 15 is MSB)  
.................... // Returns     : none 
.................... /****************************************************************************/ 
....................  
.................... void BitSetP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... void BitClearP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... void BitInvtP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitTestP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                      PROTOTYPES OF LOCAL FUNCTIONS                     **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED VARIABLES                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                            GLOBAL VARIABLES                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED FUNCTIONS                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... int16u BitSet (int16u dat, int16u bitPos) 
.................... { 
.................... 	bitPos = bitPos % 16; 
.................... 	dat = dat | (1<< bitPos); 
.................... 	return dat; 
.................... } 
....................  
.................... int16u BitClear (int16u dat, int16u bitPos) 
.................... { 
.................... 	bitPos = bitPos % 16; 
.................... 	dat = dat & (~(1<< bitPos)); 
.................... 	return dat; 
.................... } 
....................  
.................... int16u BitInvt (int16u dat, int16u bitPos) 
.................... { 
.................... 	bitPos = bitPos % 16; 
.................... 	dat = dat ^ (1 << bitPos); 
.................... 	return dat; 
.................... } 
....................  
.................... int16u BitTest (int16u dat, int16u bitPos) 
.................... { 
.................... 	bitPos = bitPos % 16; 
.................... 	dat = (dat & (1 << bitPos)) >> bitPos; 
.................... 	return dat; 
.................... } 
....................  
.................... void BitSetP (int16u *datPtr, int16u bitPos) 
.................... { 
.................... 	bitPos = bitPos % 16; 
.................... 	*datPtr = *datPtr | (1<< bitPos); 
.................... 	return; 
.................... } 
....................  
.................... void BitClearP (int16u *datPtr, int16u bitPos) 
.................... { 
.................... 	bitPos = bitPos % 16; 
.................... 	*datPtr = *datPtr & (~(1 << bitPos)); 
.................... 	return; 
.................... } 
....................  
.................... void BitInvtP (int16u *datPtr, int16u bitPos) 
.................... { 
.................... 	bitPos = bitPos % 16; 
.................... 	*datPtr = *datPtr ^ (1 << bitPos); 
.................... 	return ; 
.................... } 
....................  
.................... int16u BitTestP (int16u *datPtr, int16u bitPos) 
.................... { 
.................... 	int16u result; 
.................... 	bitPos = bitPos % 16; 
.................... 	result = (*datPtr & (1<< bitPos)) >>bitPos; 
.................... 	return result; 
.................... } 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             LOCAL FUNCTIONS                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                                 EOF                                    **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  

Configuration Fuses:
   Word  1L: 3F7F   WPOSTS16 WDT128 WINDIS NOWDT ICSP1 NODEBUG NOWRT NOPROTECT NOJTAG
          H: FF00  
   Word  2L: F9C7   NOPR NOALTI2C1 NOIOL1WAY OSCIO FRC_PLL SOSC_SEC WUT_DEFAULT IESO
          H: FF00  
